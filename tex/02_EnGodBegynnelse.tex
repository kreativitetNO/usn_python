\chapter{En god begynnelse}
Dette kompendiet er en praktisk (og ganske uformell) innføring i Python. Den går ikke i dybden på det tekniske, og er ikke en uttømmende kilde til informasjon om de forskjellige temaene som tas opp. Målet er å komme fortest mulig i gang med praktisk problemløsning og øke motivasjonen til å lære mer.

\section{Våre første små tester}

I denne delen ser vi først på hvordan vi kommer i gang med Spyder. Dette er et utviklingsverktøy som lar oss skrive og kjøre Python både interaktivt og ved å skrive programmer.

\subsection{Først litt om Spyder}
\begin{figure}[t]
\begin{center}
\includegraphics[width=0.95\textwidth]{img/spyder_overview.png}
\end{center}
\caption{Spyder}
\label{fig:spyder_overview}
\end{figure}

Start Spyder. Du skal da på skjermen ha et stort vindu med tittel \emph{Spyder (Python 3.6)} (se figur~\ref{fig:spyder_overview}). Helt øverst er den vanlige menylinjen: \usnmenulabel{File}, \usnmenulabel{Edit}, \usnmenulabel{Search}\ldots. Like under er der en linje med forskjellige ikoner. Dette er ulike toolbars. De er snarveier til funksjonaliteter som også kan nås fra menylinjen. Toolbarene kan flyttes rundt eller fjernes helt ved \usnmenulabel{View}\usnsubmenusep\usnmenulabel{Toolbars} og klikke de av.) Vi trenger ikke tenke på disse ennå. 

Under linjen med toolbars på venstre side har du Editor-vinduet. Det er et tekstbehandlingsprogram.  Her er det du skriver inn Python programmet ditt, linje for linje. Du kan flytte deg rundt med piltastene (og musen). Ikke skriv noe ennå. 

Hvis dette er første gangen du bruker Spyder, vil Spyder ha lagt inn noe tekst i et nytt dokument. På linje 5 eller 6 vil det stå \usninlinecode{@author} og brukernavnet ditt. Navnet på filen står øverst, noe slikt som \usnfilename{untitled1.py}. Dette er en fil som Spyder har åpnet og som ikke gjør noe ennå. Hvis du allerede har brukt Spyder litt, vil kanskje den siste filen/programmet du arbeidet med være i editoren.

Når programmet (det du har skrevet inn) er klart, kjører (eksekverer, execute) du det ved å trykke på den grønne \usnbuttonlabel{Play}-knappen, like under menylinja øverst. (Den viser \emph{Run file (F5)} når du holder musepekeren over knappen). Ikke gjør det nå. Vi skal ikke bruke editoren nå helt i begynnelsen.

Nederst på høyresiden har du Python/IPython-vinduet, også kalt konsollen (Console). Nederst står det \usntablabel{Python console}, \usntablabel{IPython console} og/eller \usntablabel{History log} avhengig av hvilken versjon du kjører. Klikk på fanen \usntablabel{IPython console}. Du kan også bruke Python console, men IPython er å foretrekke. I IPython-vinduet kan du skrive Python kommandoer direkte inn. Det skal vi gjøre mye av nå i begynnelsen. (I'en i IPython står for interaktivt, dvs. to-veis kommunikasjon mellom deg og Python.)

På høyresiden over IPython-konsollen er det et vindu. Dette har fanene \usntablabel{Help}, \usntablabel{Variable explorer} og \usntablabel{File explorer}. Litt mer om det nedenfor. 

Python har mange kommandoer (funksjoner) innebygd. Det er disse vi bruker når vi programmerer. Den første funksjonen vi trenger er \usninlinecode{print()} (skriv til skjerm), Klikk på (inne i) IPython-vinduet for å aktivere det. Skriv så første linja nedenfor og trykk \usnkeypress{enter}:
\begin{lstlisting}
print(365)
\end{lstlisting}
Python skriver ut \usnvarvalue{365}.

Prøv:
\begin{lstlisting}
print("Hei Python")
\end{lstlisting}

(Merk at tekst må stå innenfor hermetegn)

\usninlinecode{print()} er en funksjon, og funksjoner tar argumenter i parentes. Argumentet til \usninlinecode{print()} er det som skal printes, her tekststrengen \usnvarvalue{Hei Python} eller tallet \usnvarvalue{365}.

\subsubsection{Variabler}
En variabel er noe som inneholder en verdi. En variabel har både et navn og en verdi. Vi kan opprette en variable slik:

\begin{lstlisting}
min_var1 = "Hei Python!"
\end{lstlisting}

Navnet er \usnvarname{min\_var1}, verdien er \usnvarvalue{"Hei Python"}. Det er en \emph{tekststreng} (str).

Enda et eksempel:
\begin{lstlisting}
min_var2 = 365
\end{lstlisting}

Navnet er \usnvarname{min\_var2}, verdien er \usnvarvalue{365} og det er et \emph{(hel)tall} (int).

Vi kan endre verdien slik:
\begin{lstlisting}
min_var2 = 300
\end{lstlisting}

Du kan ha så mange mellomrom du vil (eller ikke i det hele tatt). linjene over kan også skrives som: 
\begin{lstlisting}
min_var2=300
min_var2= 300
min_var2 =300
\end{lstlisting}

Men du kan ikke skrive \usninlinecode{min var2 = 300}; for variabelen heter \usnvarname{min\_var2}, og den må være i ett ord. 

Nå kan vi skrive ut variabelen:
\begin{lstlisting}
print(min_var1)
\end{lstlisting}
Flere variabler og verdier kan printes samtidig:
\begin{lstlisting}
print(min_var1, "Det er", min_var2, "dager i et år.")
\end{lstlisting}

I IPython-vinduet kan du bruke piltastene for å hente frem igjen det du har skrevet tidligere. Prøv \usnkeypress{piltast opp}, og \usnkeypress{piltast ned} igjen. Du kan også endre på linja, og trykke \usnkeypress{enter} for å kjøre linja, eller viske ut linja ved å trykke \usnkeypress{piltast ned} til du får tom linje.) Du kan se alt du har skrevet i vinduet ved å trykke på \usntablabel{History log} nederst.

\subsection{Variable explorer}

Nå har du definert et par variabler: \usnvarname{min\_var1} og \usnvarname{min\_var2}. I vinduet oppe til høyre (se figur~\ref{fig:spyder_overview}), kan du se innholdet til variablene. Klikk på tab-en \usntablabel{Variable explorer}. Det kan være nyttig når du har litt større programmer og programmet ikke helt oppfører seg som du tenkte.

I IPython-vinduet trenger du ikke bruke \usninlinecode{print} for å se verdien til en variabel, bare skriv navnet og trykk \usnkeypress{enter}:
\begin{lstlisting}
min_var1
\end{lstlisting}

Det blir ikke helt som med print. Hermetegnene vises. Og det er dessuten enkle hermetegn, og ikke doble som vi brukte. Både doble og enkle hermetegn kan brukes i Python. Men de må stemme parvis. Du kan ikke skrive:

\begin{lstlisting}
min_var3 = 'Hei"
\end{lstlisting}

Da får du en feilmelding: \usnoutput{SyntaxError}.

\subsection{Feilmeldinger}

Når du skriver noe som Python ikke forstår, får du en feilmelding.  Lag noen feil og se hva Python svarer:
\begin{lstlisting}
asdf
\end{lstlisting}

Du får \usnoutput{NameError}. Python aner ikke hva \usninlinecode{asdf} skal bety.

\begin{lstlisting}
'asdf'
\end{lstlisting}

Nå er \usninlinecode{asdf} innenfor hermetegn, og da er det bare en verdi. Python klager ikke.

\begin{lstlisting}
a = "asdf
\end{lstlisting}
Nå får du feilmeldingen \usnoutput{SyntaxError: EOL while scanning string literal} fordi den ikke fant avsluttende hermetegn.

Du vil komme borti flere feilmeldingerstyper. Det er viktig å skjønne hva feilmeldingen betyr. I interaktiv kjøring, er det alltid siste kommando som er feil, så vi vet hvor feilen er. Når vi kjører et program fra fil og noe går galt, forteller Python i hvilken linje feilen oppstod.

\subsection{Tab-completion}

\usntablabel{IPython}-vinduet ditt kan hjelpe deg med å skrive raskere. F.eks. skriv \usninlinecode{pri} og trykk \usnkeypress{tab}. IPython fullfører så med å legge til \ldots\usninlinecode{nt} så det blir \usninlinecode{print}. Det er den i stand til fordi der kun er én kommando som begynner med \usninlinecode{pri}\ldots. Dersom du bare skriver \usninlinecode{pr} og trykker \usnkeypress{tab} kommer det opp noen flere alternativer. Du kan velge med piltastene og \usnkeypress{enter} eller \usnkeypress{tab}, eller trykke \usnkeypress{escape} for å kansellere.

Tab-completion plukker også opp variabler. Dersom du skriver \usninlinecode{mi} og trykker \usnkeypress{tab}, blir en \ldots\usninlinecode{n} lagt til så du har \usnvarname{min}, og du får flere alternativer, \usninlinecode{min} (som er en funksjon som vi skal komme tilbake til), eller variablene du selv har definert, \usnvarname{min\_var1}, \usnvarname{min\_var2} og \usnvarname{min\_var3}.

Noen ganger henger IPython-vinduet, og du må restarte for å komme videre. Eller du har kanskje lyst til å bli kvitt alle variablene du har definert og starte med blanke ark.  Da kan du trykke på \usnmenulabel{Consoles} i hovedmenyen øverst, og deretter \usnmenulabel{Restart kernel}. Da går det noen sekunder, så kommer et nytt, rent IPython-vindu opp. ({\em NB: du mister altså alle variablene du har laget. Du trenger ikke gjøre det nå.})

Du kan også ha flere IPython- og/eller Python-terminaler oppe samtidig. Klikk \usnmenulabel{Consoles}, og deretter \usnmenulabel{Open an IPython console} eller \usnmenulabel{Open a Python console}.

\subsection{Litt mer om Spyder: Layout} 
Spyder er en \emph{GUI} (Graphical User Interface/grafisk brukergrensesnitt) som gjør det enklere å arbeide med Python. Spyder eksisterer for Windows/MacOS/Linux og er open source og gratis. Vi har installert det som en del av Anaconda eller Miniconda. (Det går også an å kjøre Python uten Spyder.)

Spyder har mange funksjonaliteter. Se de mange valgene i hovedmenyen øverst i vinduet. En av disse er hvordan layouten skal være. Trykk på \usnmenulabel{View}\usnsubmenusep\usnmenulabel{Window layouts}. Sannsynligvis er det \emph{Spyder Default Layout} du bruker. Du kan velge en av de andre, f.eks. {\em Matlab Layout}. Den gir deg flere vinduer med informasjon som kan være nyttig. Men vi holder oss til \emph{Spyder Default Layout} for nå.

Du kan justere størrelsen på vinduene ved å klikke og dra rammene.

Du kan øke/minske tekststørrelsen i Editor-vinduet og IPython vinduet (uavhengig av hverandre) med \usnkeypress{CTRL-+} eller \usnkeypress{CTRL- --} mens vinduet er aktivt.

Noe som kan være praktisk nå i begynnelsen, er muligheten til å lagre alt som er gjort i IPython-vinduet. Aktiver IPython-vinduet. Trykk så \usnkeypress{CTRL-S}. Da kommer et vindu opp som lar deg lagre IPython-aktiviteten som html-fil. Velg et passende navn og katalog. Filen må leses med en nettleser (Firefox, IE/Edge, Safari). (Enten kan du finne filen med f.eks. Windows Explorer, dernest klikke på den. Eller du kan åpne en ny fane/vindu i nettleseren og skrive file:/// i url-en. Da vil du få opp filstrukturen din. Du må da klikke deg frem til rett sted og finne filen.) Det går imidlertid ikke an å laste det inn igjen i spyder og slik fortsette der du slapp. 

\subsection{Oppgaver}

\begin{exercise}
Bruk et minutt eller to på å gjøre deg litt kjent med Spyder. Endre litt på vindusstørrelse, klikke på ulike faner og sjekke hva menyene inneholder.
\end{exercise}
\begin{exercise}
Lag to variabler som inneholder tall. Lag to variabler som inneholder tekst. Skriv ut innholdet av de fire variablene. Se om de er i \usntablabel{Variable explorer}-vinduet. Endre innholdet til en av variablene. Se om variabelverdien endres i Variable explorer.
\end{exercise}
\begin{exercise}
Lagre en html-fil med IPython-aktiviteten din og finn den igjen med en nettleser.
\end{exercise}

\paragraph*{Mer info}
For mer informasjon om Sypder, klikk på Help-fanen på vinduet øverst til høyre (som også har fanen Variable explorer). Der kan du --- ved anledning --- følge en tutorial som beskriver ganske greit hva Spyder har å tilby.

\section{Tall}

\begin{usnintro}
\begin{itemize}
\item Tall, matematikk
\item Operasjoner: +, -, *, /, **, parenteser
\end{itemize}
\end{usnintro}

\begin{usncomment}
Python leser ikke det som står til høyre for \# på en linje. Det kaller vi en kommentar, så den delen trenger du ikke skrive, bare mattestykket. Du kan også ha en hel linje som starter med \#, en kommentarlinje.
\end{usncomment}

Prøv følgende:

\begin{lstlisting}
# Dette er en kommentar. Her kan jeg skrive noe stygt som Python ikke leser ... (Python er et dårlig språk)
2+2   # pluss, addisjon
4-2   # minus, subraksjon
2*3   # gange, multiplikasjon
7/3   # dele, divisjon
2**3  # opphøyd i, dette er 2*2*2
\end{lstlisting}

Maskinen regner ikke fra venstre mot høyre. Den har regler for hva som skal regnes ut først:
\begin{enumerate}
\item ** (opphøyd i)
\item * og / (ganger og deler)
\item + og - (pluss og minus)
\end{enumerate}

\begin{lstlisting}
4+3*2   # 14 eller 10? 
3*2**2  # 36 eller 12?
\end{lstlisting}

(Det andre svaret er riktig i begge tilfeller.)

Men hva gjør vi om det faktisk er slik at vi vil at 4+3 skal regnest ut først, så skal vi gange resultatet med 2? Da bruker vi parenteser. Parenteser har enda høyere prioritet enn **, dvs. det som er inni en parentes blir alltid regnet ut først. Så, vil vi regne ut 4+3 først, gjør vi det slik: 
\begin{lstlisting}
(4+3)*2
\end{lstlisting}

(Er det forskjell på 4+(3*2) og 4+3*2?)

Disse prioriteringsreglene er de samme som på kalkulatoren din. 

Du kan ha mellomrom (space) hvor som helst mellom de ulike elementene på en linje, de spiller ingen rolle.

\begin{lstlisting}
4 + 3*2
4+3 * 2 
\end{lstlisting}

Men første tegn er hellig, det må stå der det skal stå. Linja under vil derfor gi feilmelding (IndentationError) siden linja starter med et mellomrom.
\begin{lstlisting}
 4+3*2
\end{lstlisting}

Når du skriver det direkte inn i IPython-konsollen, får du (dessverre) ikke feilmelding i linja over. IPython-konsollen forstår hva som er ment. Python-konsollen vil imidlertid gi feilmelding. Prøv. (Du må da klikke på Python console nederst. Og etterpå tilbake til IPython.) Og hvis du gjør det i et program, som er det vi vanligvis vil gjøre, får du også feilmelding. 

Du kan naturligvis heller ikke sette et mellomrom midt i et tall, f.eks. skrive 44 + 3 som 4 4 + 3). 

Vi bruker de matematiske operasjonene til å regne ut ting og tang. Vanligvis gjør vi det slik:

\usnoutput{EN VARIABEL = ET REGNESTYKKE}

Dette er metakode, dvs. ikke virkelig kode, men kode-aktig. Den vil ikke fungere om du skriver den inn i IPython-konsollen. Mer standardisert måte er å omslutte forklaringene i vinkelparenteser.

\usnoutput{<en variabel> = <et regnestykke>}

(Den fungerer fortsatt ikke i IPython-konsollen.) Det som er omsluttet skal erstattes av syntaktisk korrekt kode. Du vil ofte møte slik kode, f.eks. når du leter på nettet.

Eksempel (på matematikk, ikke på metakode)

\begin{lstlisting}
a = 5 + 3
\end{lstlisting}

Her blir variabelen \usnvarname{a}, som er på venstresiden, satt til å være lik 5 + 3, altså 8. (Det kan du se ved å bare skrive a, eller print(a). Du ser det også i Variable explorer.) Dette kalles tilordning (assignment), \usnvarname{a} blir tilordnet verdi \usnvarvalue{8}. Der er litt ulike meninger om man bør ha mellomrom mellom tallene og tegnene. Det finnes visse stil-standarder. Litt mer om dette senere. 

Ofte er det ikke bare tall som står på høyresiden, men også andre variabler. 

\begin{lstlisting}
b = 2*a + 3  # Her får variabelen b verdien 2*8 + 3 = 19  (fordi a = 8, se ovenfor).
\end{lstlisting}

Hvis \usnvarname{a} ikke er definert, vil du få feilmelding. Prøv i stedet: 

\begin{lstlisting}
b = 2*c + 3 
\end{lstlisting}

Da klager Python (rettmessig) over at \usnvarvalue{c} ikke er definert. Det er også mulig at den variabelen som står på venstresiden også står på høyresiden.

\begin{lstlisting}
a = 2*a + 3
\end{lstlisting}

Men hvordan skal det forstås? Hvordan forstår Python det? Regelen er at høyresiden regnes ut først, så blir venstresiden, som alltid må være en variabel, satt lik denne verdien. Variablen \usnvarname{a} blir altså her \usnvarvalue{19} til slutt. (\usnvarname{a}'en på høyresida er \usnvarvalue{8}, men når linja er ferdig utført, har \usnvarname{a} fått verdi \usnvarvalue{19}.) Linjen ovenfor skal altså {\em ikke} leses som en ligning. Den matematiske ligningen $a = 2a + 3$ har løsning $a = -3$.

Og det er ikke det som skjer i denne linja. Det kan virke merkelig å bruke samme variabel på høyre og venstre side. Men det er ofte brukt. 

Kan vi skrive følgende ligning?

\begin{lstlisting}
x + 5*3 = 3
\end{lstlisting}

(Nei. Prøv. Det gir SyntaxError.) Har vi en variabel som er definert gjennom en ligning, og vi vil at Python skal regne ut denne variablen, da må vi først løse ligningen (på ark) slik at vi får variabelen alene på venstresiden. For ligningen ovenfor blir det slik: 

\begin{lstlisting}
x = 3 - 5*3
\end{lstlisting}

NB: Der finnes en pakke (package) i python som løser ligninger for oss: sympy. Den kan regne algebraisk, symbolsk. Da slipper vi å løse ligningen selv. Vi skal se på sympy senere. 

\subsection{Oppgaver}

I oppgavene nedenfor: regn ut for hånd (kalkulator). Prøv så i Python. 

\begin{exercise}
Hva blir 2*3-4/2*2, (1-3)*(-3)/(2*2), 2*3**2/2, 1/2**3-4-8/2*4, 2**3-(4-8)/2*4?  
\end{exercise}
\begin{solution}
2, 1.5, 9, -19.875, 16
\end{solution}

\begin{exercise}
Regn ut arealet av en firkant med side a=3 og b=12.
\end{exercise}

\begin{exercise}
Regn ut omkretsen av en firkant med side a=4 og b=5.
\end{exercise}

\begin{exercise}
Løs 3x - 2 = 13 
\end{exercise}

\begin{exercise}
Regn ut omkretsen av en sirkel med radius 3. (Hva er radius? Og pi? Diskuter med sidemannen.)
\end{exercise}

\section{Datatyper 1 : int, float, str}

Verdien til en variabel er alltid av en viss type, f.eks. en tekststreng eller et heltall eller et desimaltall. Typen avgjør hva vi kan gjøre med variabelen. For eksempel kan to tall multipliseres (ganges) med hverandre.

\begin{lstlisting}
3.3*4.1
\end{lstlisting}

Men det gir ikke mening å gange to tekststrenger med hverandre.

\begin{lstlisting}
'asdf' * 'abc'
\end{lstlisting}

Da klager Python. (Men det gir faktisk mening å skrive 3 * 'abc'. Prøv.) 

Funksjonen type() forteller oss hvilken datatype en variabel (eller en verdi) har. 

Prøv: 
\begin{lstlisting}[caption={type()\label{lst:type}}]
type(23)               # int    (integer, heltall) 
type(23.3)             # float  (desimaltall) 
type(23.0)             # float  
type('23')             # str    (tekststreng) 
a = 43.3
type(a)
\end{lstlisting}

Merk at vi for desimaltall bruker punktum, ikke komma. (Det er engelskspråklig stil, som er den som er brukt i programmering.) Vanligvis vil argumentet ikke være et tall, men en variabel, f.eks. \usninlinecode{type(min_var)}.

Noen ganger er det viktig å skille mellom int og float, men som oftest ikke. (I tidligere versjoner av Python, er det veldig viktig å skille mellom int og float. I Python2 vil 1/2 ikke gi 0.5, men 0 fordi det er såkalt heltallsdivisjon.  Vi kjører Python3, nærmere bestemt Python 3.6)

\subsection{Omgjøring av datatyper --- recast}

Fra tall til tekst: 
\begin{lstlisting}
str(33.0)        # gir '33.0'
str(33)          # gir '33'
type(str(33))    # str
a = 334
str(a)
type(str(a))     # str
\end{lstlisting}

Fra tekst til tall:

\begin{lstlisting} 
int('345')       # gir 345
float('345')     # gir 345.0  (float) 
float('345.3')   # gir 345.3 
int('345.3')     # gir feilmelding
\end{lstlisting}

Fra int til float: 
\begin{lstlisting}
float(33)        # gir 33.0
\end{lstlisting}

Fra float til int:
\begin{lstlisting}
int(33.3)        # gir 33
int(33.6)        # gir 33 (!)
\end{lstlisting}

int() runder altså ikke av slik vi er vant til, den bare fjerner desimaldelen. 

Der er en annen funksjon som runder av, round().

\begin{lstlisting}
round(33.5)      # blir 34 
round(33.499)    # blir 33
\end{lstlisting}

Med round kan du også runde av til et gitt antall desimaler (default er null desimaler).
\begin{lstlisting}
round(33.499,2)  # blir 33.50
round(33.43,1)   # blir 33.4
\end{lstlisting}

(NB: vanligvis er det variabler vi har som argumenter, ikke verdiene selv.)  

\subsection{Oppgaver}

\begin{exercise}
Du har to tekstvariabler, a = ' 7.3' og b = '30.1'. Bruk korrekt omgjøring av datatyper og finn så differansen (den ene minus den andre), summen og produktet (den ene ganget med den andre).
\end{exercise}
\begin{solution}
\begin{lstlisting}
tallA = float(a)
tallB = float(b)

print(tallA-tallB)
print(tallA+tallB)
print(tallA*tallB)
\end{lstlisting}
\end{solution}

\begin{exercise}
Du har c = '7.345'. Er det mulig å runde av tallet til to desimaler på bare en linje?
\end{exercise}
\begin{solution}
\begin{lstlisting}
c = '7.345'
print(round(float(c), 2))
\end{lstlisting}
\end{solution}

\begin{exercise}
Du har en variabel \usninlinecode{a = 3.14} og \usninlinecode{b = "Pi er "}. Lag en tekststreng \usnvarname{c} som kombinerer \usnvarname{a} og \usnvarname{b} og gir verdien \usnvarvalue{"Pi er 3.14"}.
\end{exercise}
\begin{solution}
\begin{lstlisting}
a = 3.14
b = "Pi er "
c = b + str(a)
print(c)
\end{lstlisting}
\end{solution}

\section{Importere pakker}

Python har en del innebygde funksjoner. Disse er tilgjengelig idet vi starter opp Python. F.eks. alt vi har nevnt så langt: \usninlinecode{print(), int(), float(), str(), type(), round()}. Noen flere som kan være nyttige for oss: \usninlinecode{abs(), max(), min()}.

Prøv:
\begin{lstlisting}
abs(-3)          # tar absoluttverdien (dvs. fjerner eventuelt minus foran)
abs(-3.3)
max(1,3,99,-29)  # finner maksimumsverdi av en liste med tall
min(1,3,99,-29)  # finner minimumsverdi 
\end{lstlisting}

Men mye mer er tilgjengelig som pakker (packages) som vi kan laste inn etter behov. F.eks. finnes det en pakke som heter \usninlinecode{math}. Der finnes blant annet \usninlinecode{pi} (3.14159...) og \usninlinecode{sqrt()} (kvadratrot) og \usninlinecode{sin()} (sinus). For å bruke det som finnes i pakken, må vi først importere den.

\begin{lstlisting}
import math
\end{lstlisting}

Da kan vi skrive f.eks:
\begin{lstlisting}
math.pi
\end{lstlisting}

For å se hva som finnes i math, kan vi skrive \usninlinecode{math.} (math og punktum) og trykke\usnkeypress{tab}. Da kommer det opp en liste over funksjoner og konstanter:

Prøv:
\begin{lstlisting}
math.sqrt(9)         # Kvadratroten (square root, sqrt)
math.sqrt(2)         # 
math.sin(1.57)       # Skal bli nesten 1
math.sin(math.pi/2)  # Skal bli akkurat 1
\end{lstlisting}

\begin{usncomment}
De trigonometriske funksjonene tar argumentet i radianer, ikke i grader. Har du vinkelen i grader, må du først regne om til radianer. 180 grader tilsvarer pi (radianer). (pi er 3.14159265...) Så har du g grader tilsvarer det $r = \pi * g / 180$  radianer. (Og har du r radianer, tilsvarer det $g = 180 * r / \pi$  grader.)
\end{usncomment}

Der er også funksjoner som gjør akkurat disse omregningene:  \usninlinecode{math.radians()} og \usninlinecode{math.degrees()}. Prøv.

Det finnes et knippe forskjellige måter å importere en pakke på. Du vil sannsynligvis møte alle metodene når du leser andre sin kode, så det er greit å ha sett dem. Du vil sannsynligvis bruke flere av metodene selv.

Metode 1: (den vi hadde ovenfor)
\begin{usncodebox}
import math
print(math.pi)
\end{usncodebox}
Du må ha \usninlinecode{math.} foran funksjoner/konstanter fra pakken

Metode 2:
\begin{usncodebox}
import math as ma
print(ma.pi)
\end{usncodebox}
Som første metoden, men pakken blir hetende \usninlinecode{ma} i stedet for \usninlinecode{math}.

Metode 3:
\begin{usncodebox}
from math import pi,sin, sqrt
print(pi)
\end{usncodebox}
I dette tilfellet importerer du kun \usninlinecode{pi, sin() og sqrt()} fra pakken. Du slipper å ha math. foran. 

Metode 4:
\begin{usncodebox}
from math import *
print(pi)
\end{usncodebox}
Som ovenfor, du slipper å ha \usninlinecode{math.} foran, men du importerer alle funksjonene i pakken. Dette er unødvendig, og generelt ikke anbefalt. (Faren er at pakken kan ha en variabel eller funksjon med samme navn som noe du har definert tidligere, og vil da erstatte denne. For små programmer er imidlertid faren kontrollerbar.) 

Pakken \usninlinecode{math} er del av det såkalte Python Standard Library \url{https://docs.python.org/3/library/}. Vi skal bruke noen av pakkene der. Bl.a. pakken \usninlinecode{random}. Denne bruker du til å velge tilfeldige tall. Den er nyttig f.eks. i spill. Vi skal bruke den om litt. 

\begin{usncodebox}
import random
random.random()          # gir et tilfeldig desimaltall mellom 0 og 1
random.uniform(7,17)     # gir et tilfeldig desimaltall mellom 7 og 17
random.randint(1,6)      # gir et tilfeldig heltall mellom 1 og 6
\end{usncodebox}

Hvis du har importert math i alle mulige fasonger (ovenfor), kan det være på sin plass å restarte IPython-konsollen (\usnkeypress{CTRL+.}) før du begynner på oppgavene nedenfor. 

\subsection{Oppgaver}

\begin{exercise}
En rett vinkel er 90 grader. Finn sin og cos til en rett vinkel.
\end{exercise}
\begin{solution}
\begin{lstlisting}
from math import sin, cos, radians
print(sin(radians(90)), cos(radians(90)))
\end{lstlisting}
\end{solution}

\begin{exercise}
Finn et tilfeldig desimaltall mellom 0 og 1, mellom -5 og 5, mellom -2 og 18.
\end{exercise}
\begin{solution}
\begin{lstlisting}
import random
print(random.uniform(0, 1))
print(random.uniform(-5, 5))
print(random.uniform(-2, 18))
\end{lstlisting}
\end{solution}

\begin{exercise}
Finn et tilfeldig heltall mellom 0 og 9, mellom -5 og 5, mellom -2 og 18. Grensene skal være med.
\end{exercise}
\begin{solution}
\begin{lstlisting}
import random
print(random.randint(0, 9))
print(random.randint(-5, 5))
print(random.randint(-2, 18))
\end{lstlisting}
\end{solution}

\begin{exercise}
Finn cos og sin til 35 grader. Regn også ut kvadratet av sin og av cos, og ta summen.
\end{exercise}
\begin{solution}
\begin{lstlisting}
from math import sin, cos, radians
print(cos(radians(35)))
print(sin(radians(35)))
print(cos(radians(35))*cos(radians(35))+sin(radians(35))*sin(radians(35)))
# Mer oversiktlig:
cos35 = cos(radians(35))
sin35 = sin(radians(35))
print(cos35*cos35+sin35*sin35)
\end{lstlisting}
\end{solution}

\begin{exercise}
Finn cos og sin til 2.3 radianer.
\end{exercise}
\begin{solution}
\begin{lstlisting}
import math
print(math.cos(2.3))
print(math.sin(2.3))
# Alternativt
nummer = 2.3
print(math.cos(nummer))
print(math.sin(nummer))
# Dette gjør det enklere å endre fra 2.3 til et annet tall
\end{lstlisting}
\end{solution}

\begin{exercise}
Finn kvadratroten av 256.
\end{exercise}
\begin{solution}
\begin{lstlisting}
import math
print(math.sqrt(256))
\end{lstlisting}
\end{solution}

\section{input - lese fra tastaturet}

Få opplysninger fra brukeren ved funksjonen \usninlinecode{input()}:
\begin{usncodebox}
navn = input("Hva heter du? ") 
print("Du heter", navn)
\end{usncodebox}

\usninlinecode{input()} leser inn en tekststreng. Selv om du skriver et tall, vil input gi en tekststreng.
\begin{usncodebox}
alder = input("Hvor gammel er du? ")   # svar med et tall 
print(alder)
type(alder)
\end{usncodebox}

Type avslører at det er en tekststreng. Derfor kan du ikkje gjøre følgende:
\begin{usncodebox}
print(alder + 13)
\end{usncodebox}

Feilmelding (TypeError), du ikke kan legge sammen et tall og en tekst. 

Hvis det er et tall du ønsker å lese inn (alder), må du selv gjøre om til tall:
\begin{usncodebox}
alder = int(alder)
\end{usncodebox}

(Evt. kunne du brukt alder = float(alder).) Nå har du gjort om alder til heltall.

Da fungerer dette fint: 

\begin{usncodebox}
print("Om", 13, "år er du", alder+13, "år") 
\end{usncodebox}

NB: dersom du bruker int(alder), men oppgir f.eks. '21.5', vil du få feilmelding. 

\subsection{Oppgaver}

\begin{exercise}
Be om et tall med input(). Gjør den innleste verdien om til float, og finn til slutt kvadratroten og multipliser med pi. 
\end{exercise}
\begin{solution}
\begin{lstlisting}
import math
tall = float(input("Skriv inn et tall: "))
print(math.sqrt(tall)*math.pi)
\end{lstlisting}
\end{solution}

\section{Lage et program}

La oss nå lage et program, dvs. opprette en fil og kjøre (eksekvere) den.  Klikk på vinduet til venstre, editoren.  Dersom du ikke har lastet inn en fil, vil editoren inneholde følgende tekst (omtrent): 

\begin{usncodebox}
# -*- coding: utf-8 -*-
"""
Created on Sun Aug  6 18:49:51 2017

@author: nobody
"""
\end{usncodebox}

Dersom du har et annet program (en annen fil) inne i editoren, kan du begynne på en ny fil ved å trykke på \usnmenulabel{File}\usnsubmenusep\usnmenulabel{New file}. Programmet/filen vil da bli hetende noe sånt som \usnfilename{untitled0.py} inntil du gir den et bedre navn med \usnmenulabel{File}\usnsubmenusep\usnmenulabel{Save as}.

Legg inn følgende tekst under det som allerede finnes, dvs. ca. fra linje 7: 

\begin{usncodebox}
navn = input("Hva heter du? ")
alder = input("Hvor gammel er du? ") 
print("Du heter", navn, "og er", alder, "år gammel.") 
\end{usncodebox}

Trykk så \usnmenulabel{File} fra menyen øverst, dernest \usnmenulabel{Save as}. Du bør nå velge en grei plass på maskinen for Python filer. Du kan også lage en ny folder med \usnbuttonlabel{New Folder}-knappen og klikke deg inn i den.

Filnavnet bør være beskrivende, f.eks. \usnfilename{tut\_prog\_{}navnogalder1.py}. Filen må ha ending \usnfilename{.py}. I Windows blir \usnfilename{.py} lagt til automatisk dersom du ikke selv gjør det.

For å kjøre filen, trykker du på den grønne pilen øverst til venstre (\usnbuttonlabel{Run file}), eller trykker \usnkeypress{F5}. I det interaktive vinduet (IPython-konsollen) får du nå spørsmål å svare på. Du må sannsynligvis først aktivere vinduet ved å klikke på det før du kan skrive inn navn (og trykke \usnkeypress{enter}) og alder (og trykke \usnkeypress{enter}). Merk at mens programmet kjøres, kan du ikke bruke IPython-konsollen til andre ting. Når du har oppgitt navn og alder avsluttes programmet. Da kan du igjen bruke det interaktive vinduet til andre ting. 

Du kan kjøre programmet på nytt ved igjen å klikke på den grønne pilen.

Dersom du gjør endringer i programmet, kan du lagre endringene ved å klikke \usnmenulabel{File}\usnsubmenusep\usnmenulabel{Save} (eller trykke \usnkeypress{ctrl-s}). Eventuelle endringer som ikke allerede er lagret, vil bli det hvis du trykker på den grønne filen og kjører programmet.

Det er viktig å bli komfortabel med filer, vite hvor de er, kunne lagre, opprette nye, laste inn filer du har laget tidligere etc.. Vanlig bruk av Python er via filer. Kun for veldig små oppgaver vil du skrive kommandoene direkte inn i IPython-konsollen. I linjen over editor-vinduet, vil det være en eller flere faner, og kanskje piler til venstre/høyre. Dette er aktive filer. Du kan klikke på en fane, så blir filen lastet inn i editoren. Dersom du har andre Python-programmer tilgjengelig på harddisken, kan du laste inn disse ved å klikke \usnmenulabel{File}\usnsubmenusep\usnmenulabel{Open}, og så finne frem til den aktuelle filen. 

\subsection{Oppgaver}

\begin{exercise}
Lag et program som leser inn fornavn, etternavn og alder i passende variabler. Omtrentlig fødselsår skal så regnes ut, og når du fyller 50 år. Skriv til slutt ut alle opplysningene.
\end{exercise}
\begin{solution}
\begin{lstlisting}
fornavn = input("Fornavn: ")
etternavn = input("Etternavn: ")
alder = int(input("Alder: "))
fodselsAar = 2018 - alder
aar50 = fodselsAar + 50

print("Du heter", fornavn, etternavn, "og er født i", fodselsAar)
print("I", aar50, "blir du 50 år")
\end{lstlisting}
\end{solution}

\begin{exercise}
Lag et program som leser inn navnet ditt, og så finner et tilfeldig tall
mellom 15 og 35, og påstår at det er alderen din.
\end{exercise}
\begin{solution}
\begin{lstlisting}
import random
navn = input("Navn: ")
print("Hei,", navn, "! Du er", random.randint(15, 35), "år.")
\end{lstlisting}
\end{solution}

\section{Betingelser}

Ofte må man i et programmet gjøre forskjellige ting avhengig av verdien til variablene. I Python gjøres dette med \usninlinecode{if}-konstruksjonen. Skriv inn følgende programsnutt i et nytt dokument og kjør det: 

\begin{usncodebox}
alder = 18
if alder < 20:            # merk kolonet og indenteringen nedenfor
   print("Tenåring")      # Dette blir utført hvis alder er mindre 20
   print("fortsatt")      # også dette, siden det også er indentert
print("Dette blir printet uansett")
\end{usncodebox}

Her er å merke seg at to linjer er forskyvd mot høyre, de er indenterte. Det som er indentert blir utført dersom alder < 20. Siste linja er ikke indentert. Det blir printet uansett alder.

Det er altså via indenteringen du forteller Python logikken i \usninlinecode{if}-setningen din. Editoren du bruker (Spyder, Emacs, ..) kjenner til indenteringsreglene i Python. Det vil derfor typisk foreslå indentering når du trykker \usnkeypress{enter} etter kolonnen. Når du er ferdig med indenteringen, må du selv avslutte den ved å trykke \usnkeypress{backspace} eller \usnkeypress{shift-tab}. 

Prøv å skrive inn manuelt (ikke copy/paste), se om Spyder oppfører seg slik den skal. 

\begin{usncomment}
Hvis du av en eller annen grunn ikke har \usnfilename{.py} som endelse på filen, vil editoren ikke nødvendigvis vite at du skriver i Python, og heller ikke hjelpe deg med indenteringen.
\end{usncomment}

\subsection{Mer komplisert if-setning}
En \usninlinecode{if}-setning kan også inneholde else, som betyr {\em otherwise/hvis ikke}. Dette utføres dersom if-betingelsen ikke er tilfredsstilt:
\begin{usncodebox}
if alder < 20: 
   print("Tenåring")
   # gjerne flere linjer
else: 
   print("Olding")     # Dette utføres dersom alder ikke er < 20
   # gjerne flere linjer
\end{usncodebox}

Du kan også teste flere alderskategorier ved hjelp av \usninlinecode{elif}, som forstås som else if:
\begin{usncodebox}
if alder < 20: 
   print("Tenåring")
elif alder < 30:           
   print("Olding")         # mellom 20 og 30 (hvorfor?) 
elif alder < 40: 
   print("Nesten ferdig")  # mellom 30 og 40 (hvorfor?)
else: 
   print("Ung igjen")  # 40 eller mer 
\end{usncodebox}

Merk logikken. Vær sikker på at du forstår hvorfor alderen må være mellom 30 og 40 på tredje siste linje. (Poenget er at hvis vi allerede har kommet til \usninlinecode{elif alder < 40}, vil vi allerede ha feilet på \usninlinecode{elif alder < 30}, dvs. alderen er 30 eller mer.) 

Mer generelt ser konstruksjonen slik ut

\begin{usncodebox}
if <betingelse>: 
   <handling>
elif <betingelse>: 
   <handling>
<evt. flere elif-bokkker>
else: 
   <handling>
\end{usncodebox}

En handling kan gå over flere linjer. 

Verdien til {\em betingelse} er \usninlinecode{True} eller \usninlinecode{False}. (Stor førstebokstav, resten små. Verdien er ikke true eller TRUE, men True.) Dette er en ny datatype: logisk (boolsk, boolean). En boolsk variabel (eller uttrykk) har altså kun to mulige verdier: \usninlinecode{True} eller \usninlinecode{False}. 

Ofte blir den produsert via følgende sammenligningsoperatorer:
\begin{tabbing}
=== \=\kill
>  \> større enn\\
<  \> mindre enn\\
== \> er lik  (NB: ved sammenligning bruker vi == ikke =)\\
<= \> mindre enn eller lik\\
>= \> større enn eller lik\\
!= \> ikke lik
\end{tabbing}

Prøv (interaktivt, dvs i IPython-konsollen):
\begin{usncodebox}
2 == 3   # False
2 = 3    # Dette må vel gi feilmelding? (Tilordning/assignment)
2 == 2   # True
2 != 2   # False
2 != 3   # True
2 < 3    # True
2 > 3    # False
2 <= 2   # True
2 >= 2   # True
2 =< 2   # SyntaxError
2 => 2   # SyntaxError
\end{usncodebox}

også:
\begin{usncodebox}
a = 2    # tilordning
a == 3   # sammenligning

navn = "Newton"       # tilordning
navn == "Einstein"    # False 
navn == "Newton"      # True
navn == "Newton "     # False
type(navn)
\end{usncodebox}

Du kan også legge resultatet av en sammenligning inn i en variabel:
\begin{usncodebox}
bet1 = (2 == 3)   
print(bet1)
type(bet1)   # bool
\end{usncodebox}

\subsection{Kombinere betingelser --- and, or, not}

interaktivt:
\begin{usncodebox}
a=2             # (tilordning)
a==1 or a==2    # True 
a>1  or  a<1    # True 
a>1  and a<1    # False
not(3==3)       # False
not(True)       # False  # not snur True til False og False til True
not(False)      # True 
\end{usncodebox}

Betingelser og logiske operatorer blir utført i en viss rekkefølge. Dersom du er usikker på om den rekkefølgen du ønsker faktisk er det Python gjør, eller om du vil fremheve logikken for den som leser koden, kan du alltid sette inn parenteser.

\subsection{Oppgaver}

\begin{exercise}
Lag et program som leser inn tre tall, gjør de om til float, så sjekker hvilket av de tre som er størst og skriver til skjerm om det var det første, andre eller tredje som ble skrevet inn.
\end{exercise}
\begin{solution}
\begin{lstlisting}
tall1 = int(input('Tast inn tall 1: '))
tall2 = int(input('Tast inn tall 2: '))
tall3 = int(input('Tast inn tall 3: '))

if tall1 > tall2 and tall1 > tall3:
    print('tall1 er størst')
elif tall2 > tall1 and tsall2 > tall3:
    print('tall2 er størst')
elif tall3 > tall1 and tall3 > tall2:
    print('tall3 er størst')
else:
    print('ingen av tallene er større enn begge de andre')
\end{lstlisting}
\end{solution}

\begin{exercise}
Lag et program som finner et tilfeldig tall mellom 1 og 10 (grenser inkludert), og så ber deg gjette tallet. Programmet sier til slutt ifrå om du gjettet for høyt, for lavt eller riktig.
\end{exercise}
\begin{solution}
\begin{lstlisting}
import random

tilfeldigTall = random.randint(1, 10)
gjetning = int(input('Prøv å gjett tallet: '))
if gjetning > tilfeldigTall:
    print('Du gjettet for høyt')
elif gjetning < tilfeldigTall:
    print('Du gjettet for lavt')
else:
    print('Du gjettet riktig')
\end{lstlisting}
\end{solution}

\begin{exercise}
Lag et program som simulerer tre terningkast og skriver ut hvor mange like det ble (3 like, 2 like eller ingen like).
\end{exercise}
\begin{solution}
\begin{lstlisting}
import random

terning1 = random.randint(1, 6)
terning2 = random.randint(1, 6)
terning3 = random.randint(1, 6)

print(terning1, terning2, terning3)

if terning1 == terning2 and terning1 == terning3:
    print('3 like')
elif terning1 == terning2 or terning2 == terning3 or terning1 == terning3:
    print('2 like')
else:
    print('ingen like')
\end{lstlisting}
\end{solution}

\begin{exercise}
Lag et program plukker to tall, x og y, mellom (f.eks.) 10 og 100. Brukeren blir så spurt om å svare på følgende regnestykker, x+y, x-y, x*y (etc?) For hvert regnestykke kontrollerer programmet svaret og skriver en kommentar. 
\end{exercise}
\begin{solution}
\begin{lstlisting}
import random

x = random.randint(10, 100)
y = random.randint(10, 100)

print('Hva er', x, '+', y, '?')
svarSum = int(input('Ditt svar: '))
if svarSum == x+y:
    print('Riktig')
else:
    print('Feil. Svaret var:', x+y)

print('Hva er', x, '-', y, '?')
svarSum = int(input('Ditt svar: '))
if svarSum == x-y:
    print('Riktig')
else:
    print('Feil. Svaret var:', x-y)

print('Hva er', x, '*', y, '?')
svarSum = int(input('Ditt svar: '))
if svarSum == x*y:
    print('Riktig')
else:
    print('Feil. Svaret var:', x*y)
\end{lstlisting}
\end{solution}

\section{Ny datatype: List}

\begin{usnintro}
Nye funksjoner: \usninlinecode{len, help, range}
\end{usnintro}

Datatypen list er en liste (sekvens) med elementer. Elementene kan være tall, tekst, andre lister eller andre ting.

Prøv i IPython-konsollen:
\begin{usncodebox}
liste1 = [1,3,5,2,33,0,2]  # deklarerer og fyller en liste med tall
type(liste1)
\end{usncodebox}

\begin{usncomment}
Du trenger å bruke hakeparentesene. Med engelsk tastatur (som ofte er det enkleste for programmering), er de lette å nå. Med norsk tastatur er det via \usnkeypress{alt gr}. (Mac: \usnkeypress{alt})
\end{usncomment}

\begin{usncodebox}
en_liste = []        # tom liste
en_liste2 = list()   # kan også lage tom liste slik

hummer = [32,'Toyota',333]   # elementene trenger ikke være av samme datatype

biler = ['Toyota','Mazda','Audi'] 
len(biler) 
\end{usncodebox}

\usninlinecode{len()} (length) er en funksjon som viser antall elementer i en liste. 

\usninlinecode{help()} er en annen funksjon. Den viser info om det du putter inni parentesen, f.eks. en funksjon

\begin{usncodebox}
help(len)
help(print)
help(list)
\end{usncodebox}

Når du putter inn en variabel, får du info om den typen det er. 
\usninlinecode{help(biler)} vil vise så å si det samme som help(list). Beskrivelsen i help kan være ganske teknisk. Det er ikke alltid så lett å finne frem til det man leter etter. Ofte er et søk på nettet raskeste vei, men \usninlinecode{help()} kan også være til god hjelp. 

Tilbake til lister.

Vi kan aksessere (rekke, nå) elementer i listen ved å angi indeksen til elementet. I Python (som i bl.a. C) starter en liste med indeks 0.(Det kan være forvirrende i begynnelsen.) 

\begin{usncodebox}
biler[0]       # den første bilen 
biler[1]       # den andre bilen
biler[2]       # den tredje (og siste) bilen
biler[3]       # IndexError
biler[len(biler)-1]   # den siste bilen (fordi vi starter på 0) 
biler[-1]      # triks. den siste bilen, faktisk. 
biler[-2]      # triks. nest siste bilen. 
biler[-3]      # triks. tredje siste bilen (som er det første)
biler[-4]      # IndexError igjen
\end{usncodebox}

Hvilke funksjoner (metoder) eksisterer for en liste? Skriv biler. og trykk \usnkeypress{tab}. Du får opp funksjoner som append, clear, count, \ldots

La oss se på noen av dem. 

Legge element bakerst i listen / Legge til elementer:
\begin{usncodebox}
biler.append("Tesla")
print(biler)
\end{usncodebox}

Legge Mercedes inn som bil nr. 3 og skyve Audi og Tesla til bil 4 og 5 biler:
\begin{usncodebox}
biler.insert(2, 'Mercedes')
print(biler)
\end{usncodebox}

Erstatte elementer:
\begin{usncodebox}
biler[1] = "Golf"
print(biler)
\end{usncodebox}

Du kan også legge til elementer på følgende måte:

\begin{usncodebox}
biler = biler + ['Honda','Renault']
# og/eller
biler = ['BMW','Volvo'] + biler
\end{usncodebox}

Du kan aksessere (velge) en del (en slice) av listen ved å spesifisere to indekser. Prøv:

\begin{usncodebox}
print(biler[2:5])
\end{usncodebox}

De to indeksene er det første elementet du vil ha med, og til det siste elementet du vil ha med PLUSS 1. biler[2:5] viser element 2, 3 og 4, som er bil 3, 4 og 5. Det kan være forvirrende.

\begin{usncodebox}
biler2 = biler[2:5] 
print(biler2)
print(biler)          # NB: biler endres ikke 
\end{usncodebox}

Prøv også:
\begin{usncodebox}
biler[1:1]   # tomt
biler[1:2]   # element 1
\end{usncodebox}

Du kan også droppe første eller andre indeks:
\begin{usncodebox}
biler[:5]     # viser de 5 første bilene
biler[2:]     # viser fra bil nummer 3 og til enden av listen
biler[-3:]    # viser de tre siste bilene
\end{usncodebox}

Hvilke flere funksjoner finnes for lister? skriv \usninlinecode{biler} og trykk \usnkeypress{tab}, da ser du funksjoner. F.eks.:

\begin{usncodebox}
biler.sort()          # sorterer listen. Her: alfabetisk sortering
print(biler)

biler.reverse()       # reverserer listen. 
print(biler)
\end{usncodebox}

\emph{NB: .sort() og .reverse() endrer listen.}

\begin{usncodebox}
biler.index('Tesla')  # angir hvilket nummer (indeks) i listen 'Tesla' har 
biler.index('Fiat')   # ValueError: 'Fiat' er ikke i listen vår 

biler.pop()           # fjerner siste element fra listen
print(biler)
\end{usncodebox}

Du kan også ``plukke opp'' det som fjernes:
\begin{usncodebox}
bil1 = biler.pop()
print(bil1)
print(biler)

biler.pop(2)          # fjerner tredje element 

biler.remove('Golf')  # fjerner 'Golf'
biler.remove('Fiat')  # ValueError
\end{usncodebox}

Teste om en gitt verdi er i listen vår:
\begin{usncodebox}
'Fiat' in biler       # False
'Toyota' in biler     # True
\end{usncodebox}

F.eks.:
if 'Fiat' in biler:
   print('Ja, har Fiat.')

\subsection{range()}

En litt spesiell måte å lage en liste på er via \usninlinecode{range}-funksjonen
\begin{usncodebox}
range(5)        # lager listen [0,1,2,3,4]  
range(2,6)      # lager listen [2,3,4,5]
range(2,13,3)   # lager listen [2,5,8,11]
\end{usncodebox}

\paragraph{Forklaring*} 
Når bare ett argument er gitt, gir det maks-grensen på listen, mens start er 0. Merk at maks-grensen selv er ikke med i listen.

Når to argumenter er gitt, er det startverdi og maks-grensen. Igjen: maks-grensen er ikke med i listen. 

Når tre argumenter er gitt, er det startverdi, maks-grensen, dernest hvor mange steg man hopper mellom hvert element. Default steg(lengde) er 1, da hopper man ikke over noe, men tar med alle. Det er det som skjer i de to første range-kallene. 

Sjekk også \usninlinecode{help(range)}
(se øverst) 

range() fungerer bare med heltall (int). (Senere skal vi introdusere arange(), som også fungerer med desimaltall (float).) 

\subsubsection{Detalj 1}
Merk at følgende kodelinjer gir samme liste.
\begin{usncodebox}
list(range(2,12,3))
list(range(2,13,3))
list(range(2,14,3))
\end{usncodebox}

\subsubsection{Detalj 2}
Det er ikke helt sant at range er en liste. Det ser du dersom du skriver f.eks. range(5) eller print(range(5)). Hvis det var en liste, ville [0,1,2,3,4] blitt printet. Men for de fleste hensyn oppfører det seg som en liste. Du kan lage den tilsvarende listen slik:
\begin{usncodebox}
list(range(5))
\end{usncodebox}

Vi bruker ofte range-funksjonen i for-løkker som vi skal se på i neste avsnitt. 

\subsection{Oppgaver}

\begin{exercise}
Lag et program som leser inn tre navn og legger de i en liste, sorterer listen alfabetisk og skriver den sortert ut til skjerm, navn for navn. 
\end{exercise}
\begin{solution}
\begin{lstlisting}
navnListe = []

navnListe.append(input("Skriv inn navn 1: "))
navnListe.append(input("Skriv inn navn 2: "))
navnListe.append(input("Skriv inn navn 3: "))

navnListe.sort()

print(navnListe[0])
print(navnListe[1])
print(navnListe[2])
\end{lstlisting}
\end{solution}

\begin{exercise}
Som ovenfor, men nå skal det sorteres motsatt vei. 
\end{exercise}
\begin{solution}
\begin{lstlisting}
navnListe = []

navnListe.append(input("Skriv inn navn 1: "))
navnListe.append(input("Skriv inn navn 2: "))
navnListe.append(input("Skriv inn navn 3: "))

navnListe.sort()
navnListe.reverse()
# Eller
#navnListe.sort(reverse = True)

print(navnListe[0])
print(navnListe[1])
print(navnListe[2])
\end{lstlisting}
\end{solution}

\begin{exercise}
Lag ved hjelp av range() følgende lister:
\begin{itemize}
\item {[0,1,2,3,4,5,6,7,8,9]}
\item {[0,2,4,6]}
\item {[2,4,6]}
\item {[5,8,11,14,17]}
\end{itemize}
\end{exercise}
\begin{solution}
\begin{lstlisting}
liste1 = range(0, 10)
liste2 = range(0, 8, 2)
liste3 = range(2, 8, 2)
liste4 = range(5, 20, 3)
\end{lstlisting}
\end{solution}

\begin{exercise}
Fjern element med indeks 3 fra listen lst1 = [0,1,2,3,4,5]. Fjern så elementet med verdi 2. Stikk så inn i listen et element 5 slik at det får indeks 2. Still så inn i listen et element 'fire' slik at det får indeks 2. Finn så hvilken indeks elementet 5 har. (NB: du har to like elementer i listen. Forstå hva funksjonen returnerer.) Fjern så elementet 5 fra listen. (Igjen, du har to elementer med verdi 5. Se hvilken som fjernes.)
\end{exercise}
\begin{solution}
\begin{lstlisting}
lst1 = list(range(6))
print(lst1)
lst1.pop(3)
print(lst1)
lst1.remove(2)
print(lst1)
lst1.insert(2, 5)
print(lst1)
lst1.insert(2, 'fire')
print(lst1)
print(lst1.index(5))
lst1.remove(5)
print(lst1)
\end{lstlisting}
\end{solution}

\begin{exercise}
Du har lst2 = [11,22,33,44,55,66,77]. Lag en ny liste som inneholder de tre midterste elementene. (Det kan gjøres på mange måter. Hva er den raskeste?)
\end{exercise}
\begin{solution}
\begin{lstlisting}
lst2 = [11,22,33,44,55,66,77]
# Raskest
lst3 = lst2[2:5]
# Alternativt
lst3 = [lst2[2], lst2[3], lst2[4]]
# Alternativt
lst3 = lst2
lst3.pop(0)
lst3.pop(0)
lst3.pop(-1)
lst3.pop(-1)
print(lst3)
\end{lstlisting}
\end{solution}

\section{For-løkke (For-loop)}

Du vil lage et program som kaster en terning 100 ganger. Du vil så telle antall ganger du får 5 eller 6. Et terningkast kan du simulere med følgende:

\begin{usncodebox}
import random
tall = random.randint(1,6)   # velger mellom 1 og 6
\end{usncodebox}

Men dette skal du gjøre 100 ganger. Det er ikke spesielt praktisk å skrive opp linjen 100 ganger. Det er her en for-løkke kommer inn. 

La oss først ta en veldig enkel \usninlinecode{for}-løkke. (Du kan skrive dette i IPython-konsollen.):

\begin{usncodebox}
for i in [0,1,2,3]:
    print(i)
\end{usncodebox}

Når du er trykker \usnkeypress{enter} etter kolon på første linje, vil IPython-konsollen selv sørge for å indentere teksten. Skriv så inn print(i) og trykk \usnkeypress{enter}, og \usnkeypress{enter} igjen på den tomme linjen etterpå. Da utføres \usninlinecode{for}-løkka.

Hvordan virker en \usninlinecode{for}-løkke? Iterasjonsvariabelen \usnvarname{i} går gjennom listen \usnvarvalue{[0,1,2,3]}. Første gangen er \usnvarname{i} lik \usnvarvalue{0}, neste gang er \usnvarname{i} lik \usnvarvalue{1} etc. For hver \usnvarname{i}-verdi blir det som er indentert utført (her kun \usninlinecode{print(i)}). Det skjer altså 4 ganger her.

Vi kunne også skrevet listen v.h.a. range(), som altså er nesten det samme som en liste.
\begin{usncodebox}
for i in range(4):
    print(i)
\end{usncodebox}

Det er praktisk dersom du f.eks. skal gjøre det hundre ganger. Da slipper du å eksplisitt skrive opp [0,1,2,....,99]

Nå er vi i stand til å utføre den lille terningtesten. 

Åpne en ny fil, dvs klikk på ikonet oppe til venstre. (Eller velg \usnmenulabel{File}\usnsubmenusep\usnmenulabel{Open}.) Skriv inn følgende (etter de første 6-7 linjene som automatisk kommer opp): 

\begin{usncodebox}
import random

# initialisering
n6 = 0  # antall seksere
n5 = 0  # antall femmere

# Løkka 
for kast in range(100):
    tall = random.randint(1,6)
    print("Kast nr", kast+1, "ble", tall)
    if tall == 6:
       n6 = n6 + 1    # øker antall seksere med 1
    elif tall == 5:
       n5 = n5 + 1    # øker antall femmmer med 1

print("Det ble totalt", n6, "seksere og", n5, "femmere.")
\end{usncodebox}

Linjer som starter med \# er kommentarlinjer. Python bryr seg ikke om disse.

Trykk på grønn pil for å kjøre programmet. Du får nå beskjed om å lagre filen. Bruk helst samme katalog som sist. Velg et passende navn, f.eks. \usnfilename{tut\_for\_terning1.py}

Hvor mange seksere ble det? Kjør en gang til.

Med for-loop på reportoaret, er det plutselig mange flere ting vi kan gjøre. 

\begin{exercise}
Hva om du brukte range(1,101) i for-linja. Hva ville endret seg? (Noen ganger bruker du tellevariabelen (iterasjonsvariabelen) inne i løkka, andre ganger er den ikke i bruk til annet enn å telle f.eks. 100 ganger.)
\end{exercise}
\begin{solution}
Da inneholder kast alle tallene fra 1 til 100 (istedenfor 0 til 99). Da hadde vi sluppet å skrive \usninlinecode{kast+1} i \usninlinecode{print()}-linja.
\end{solution}

\begin{exercise}
Tell også opp antall ganger terningen ga 1, 2, 3 og 4, og skriv ut. Forsikre deg også om at det hele summerer til 100, skriv evt. ut feilmelding.
\end{exercise}
\begin{solution}
\begin{usncodebox}
from random import randint

n1 = 0
n2 = 0
n3 = 0
n4 = 0
n5 = 0
n6 = 0

for kast in range(1, 101):
    tall = randint(1, 6)
    print("Kast nr", kast, "ble", tall)
    if tall == 6:
        n6 = n6 + 1
    elif tall == 5:
        n5 = n5 + 1
    elif tall == 4:
        n4 = n4 + 1
    elif tall == 3:
        n3 = n3 + 1
    elif tall == 2:
        n2 = n2 + 1
    else:
        n1 = n1 + 1

if n1+n2+n3+n4+n5+n6 != 100:
    print("Summen ble ikke 100. Da er det noe som gikk galt.")
else:
    print("Det ble totalt", n6, "seksere og", n5, "femmere og", n4, "firere og"
      , n3, "treere og", n2, "toere og", n1, "enere")
\end{usncodebox}
\end{solution}

\begin{exercise}
Som ovenfor, men i stedet for å bruke variablene n1, n2, ..., n6, bruk heller en liste antall som er initialisert slik: antall = [0,0,0,0,0,0]. NB: antall[0] vil da typisk innholde antall 1'ere. NB: Kan du nå forenkle testingen? Bruke bare én test-linje i stedet for seks? 
\end{exercise}
\begin{solution}
\begin{usncodebox}
import random

antall = [0,0,0,0,0,0]

for kast in range(1, 101):
    tall = randint(1, 6);
    antall[tall-1] = antall[tall-1] + 1

teller = 0
for tall in range(0, 6):
    teller = teller + antall[tall]

if teller != 100:
    print("Summen ble ikke 100. Da er det noe som gikk galt.")
else:
    print("Det ble totalt:")
    for tall in range(0, 6):
        print(antall[tall], tall+1, "-ere")
\end{usncodebox}
\end{solution}

\section{While-løkker (While-loop)}

Det er ikke alltid vi vet hvor mange ganger vi må gå iterere (gå gjennom en løkke) før vi er fornøyd. Dersom problemstillingen f.eks. er å finne ut hvor mange ganger vi må kaste terningen før vi har fått ti seksere, kan vi ikke bruke en for-løkke. En for-løkke forutsetter nemlig at vi vet akkurat hvor mange ganger løkka skal kjøres.

Løsningen ville være en while-løkke. Skriv inn og studer følgende program. Kall det gjerne \usnfilename{tut\_while1.py}

\begin{usncodebox}
import random

# initialisering
n6    = 0  # antall seksere
nkast = 0  # antall kast

while n6 < 10: 
    nkast = nkast + 1
    tall = random.randint(1,6)
    if tall == 6:
       n6 = n6 + 1    # øker antall seksere med 1
    
print("Vi brukte", nkast, "kast på å få 10 seksere")
\end{usncodebox}

While-løkke oppfører seg veldig likt en for-løkke. Det som er indentert etter while-linja, blir utført så lenge while-betingelsen, som her er n6 < 10, er tilfredsstilt. n6 starter med verdi 0. Når vi får en sekser, øker verdien av n6 til 1, etc. Når n6 har blitt 10 (og vi altså har fått 10 seksere), vil while-løkka avsluttes. Koden går videre til linjene nedenfor som ikke er indentert. 

\begin{exercise}
Lag et gangetabelltestingsprogram som først tar følgende input fra brukeren:
\begin{itemize}
\item Antall oppgaver som må klares (f.eks. 10)
\item Hvor mange poeng man får av å svare riktig (f.eks. 1)
\item Hvor mange minuspoeng man får av å svare feil (f.eks. 1)
\item Det laveste og høyeste tallet i gangetabellen som man blir spurt fra, f.eks. 5 og 12.
\end{itemize}
Da er det høyeste gangestykket 12x12, det laveste 5x5, og alt imellom er tillatt. (Så f.eks. 5x6, 5x12, 11x5, 12x5 er tillatt, men ikke f.eks. 3x11.) Deretter, i en passende loop, vil to tilfeldige tall (a og b) bli trukket. Du vil så bli spurt om produktet (a ganger b). Svarer du rett, får du poeng, svarer du feil mister du poeng. Når du har svart korrekt det bestemte antall ganger, går programmet ut av loopen. Programmet skriver så ut hvor mange forsøk du trengte og poengsummen din. (La programmet gi en positiv kommentar til brukeren hvis de får en god poengsum.) 
\end{exercise}
\begin{solution}
\begin{usncodebox}
from random import randint

antallMaaKlare = int(input("Antall oppgaver som må løses: "))
plussPoeng = int(input("Antall poeng for riktig svar: "))
minusPoeng = int(input("Antall minuspoeng for feil svar: "))
nedreGrense = int(input("Det laveste tallet i gangetabellen man blir spurt fra: "))
oevreGrense = int(input("Det høyeste tallet i gangetabellen man blir spurt fra: "))
antallForsoek = 0
antallRiktigSvar = 0
antallPoeng = 0

while antallRiktigSvar < antallMaaKlare:
    tall1 = randint(nedreGrense, oevreGrense)
    tall2 = randint(nedreGrense, oevreGrense)
    print("Hva er", tall1, "x", tall2,"?")
    svar = int(input("Ditt svar:"))
    if svar == tall1 * tall2:
        antallRiktigSvar = antallRiktigSvar + 1
        antallPoeng = antallPoeng + plussPoeng
    else:
        antallPoeng = antallPoeng - minusPoeng
    antallForsoek = antallForsoek + 1
    
if antallForsoek == antallMaaKlare:
    print("Du klarte alle!")
else:
    print("Du brukte", antallForsoek, "forsøk")
\end{usncodebox}
\end{solution}

\begin{exercise}
For å gjøre det litt gøyere, kan du også legge til tidtaking. 
Da må du importere pakken time.
Funksjonen time.time() gir deg antall sekunder (med desimaler) siden 1.1.1970.
Det kan vi bruke til å finne ut hvor lang tid noe tar.

Ved starten av programmet må du ha \usninlinecode{import time} Ved starten av løkka skriver du: \usninlinecode{t\_start = time.time()}. Ved slutten av løkka skriver du:
\end{exercise}
\begin{usncodebox}
t_slutt = time.time()
t_tid = t_slutt - t_start
print("Du brukte", t_tid, "sekunder")
\end{usncodebox}
\begin{solution}
\begin{usncodebox}
from random import randint
import time

antallMaaKlare = int(input("Antall oppgaver som må løses: "))
plussPoeng = int(input("Antall poeng for riktig svar: "))
minusPoeng = int(input("Antall minuspoeng for feil svar: "))
nedreGrense = int(input("Det laveste tallet i gangetabellen man blir spurt fra: "))
oevreGrense = int(input("Det høyeste tallet i gangetabellen man blir spurt fra: "))
antallForsoek = 0
antallRiktigSvar = 0
antallPoeng = 0

t_start = time.time()
while antallRiktigSvar < antallMaaKlare:
    tall1 = randint(nedreGrense, oevreGrense)
    tall2 = randint(nedreGrense, oevreGrense)
    print("Hva er", tall1, "x", tall2,"?")
    svar = int(input("Ditt svar:"))
    if svar == tall1 * tall2:
        print("Riktig!")
        antallRiktigSvar = antallRiktigSvar + 1
        antallPoeng = antallPoeng + plussPoeng
    else:
        print("Feil :(")
        antallPoeng = antallPoeng - minusPoeng
    antallForsoek = antallForsoek + 1
t_slutt = time.time()
t_tid = t_slutt - t_start

print("Du brukte", t_tid, "sekunder")
if antallForsoek == antallMaaKlare:
    print("Du klarte alle!")
else:
    print("Du brukte", antallForsoek, "forsøk")
print("Du fikk", antallPoeng, "poeng")
\end{usncodebox}
\end{solution}

\begin{exercise}
Mulige utvidelser:
a) Legge til mulighet for addisjon, subtraksjon og/eller divisjon. 
b) Legge til tidskrav per spørsmål.
Rett svar på spørsmålet blir ikke godkjent hvis for lang tid er brukt.
\end{exercise}
\begin{solution}
\begin{usncodebox}
from random import randint
import time

antallMaaKlare = int(input("Antall oppgaver som må løses: "))
plussPoeng = int(input("Antall poeng for riktig svar: "))
minusPoeng = int(input("Antall minuspoeng for feil svar: "))
nedreGrense = int(input("Det laveste tallet man blir spurt om: "))
oevreGrense = int(input("Det høyeste tallet man blir spurt om: "))
antallForsoek = 0
antallRiktigSvar = 0
antallPoeng = 0
operatorer = ['+', '-', '*', '/']

while antallRiktigSvar < antallMaaKlare:
    tall1 = randint(nedreGrense, oevreGrense)
    tall2 = randint(nedreGrense, oevreGrense)
    operator = operatorer[randint(0, 3)]
    print("Hva er", tall1, operator, tall2,"?")
    t_start = time.time()
    svar = round(float(input("Ditt svar:")), 1)
    t_slutt = time.time()
    t_tid = t_slutt - t_start
    if operator == '+' and svar == tall1 + tall2 \
        or operator == '-' and svar == tall1 - tall2 \
        or operator == '*' and svar == tall1 * tall2 \
        or operator == '/' and svar == tall1 / tall2:
        if t_tid <= 5:
            print("Riktig!")
            antallRiktigSvar = antallRiktigSvar + 1
            antallPoeng = antallPoeng + plussPoeng
        else:
            print("Du svarte riktig, men brukte for lang tid :(")
            antallPoeng = antallPoeng - minusPoeng
    else:
        print("Feil :(")
        antallPoeng = antallPoeng - minusPoeng
    antallForsoek = antallForsoek + 1

if antallForsoek == antallMaaKlare:
    print("Du klarte alle!")
else:
    print("Du brukte", antallForsoek, "forsøk")
print("Du fikk", antallPoeng, "poeng")
\end{usncodebox}
\end{solution}

\begin{exercise}
Sjekke (omtrentlig) om time.time() faktisk angir antall sekunder fra. 1.1.1970. 
\end{exercise}

\begin{exercise}
La Python tenke på et tilfeldig heltall mellom 1 og 100 (grenser inkludert). Lag så en løkke der du via input() gjetter på tallet til du har klart det. For hver gang du gjetter skal programmet si ifra om du gjetter for høyt eller for lavt. Når du gjetter riktig, avsluttes programmet og det skrives ut hvor mange forsøk du brukte. 

Mulige utvidelser
\begin{enumerate}
\item La brukeren selv med input() velge øvre og nedre grense for gjettingen.
\item La brukeren få mulighet til å avslutte gjettingen med f.eks. å skrive inn 'quit'.
\end{enumerate}
\end{exercise}
\begin{solution}
\begin{usncodebox}
from random import randint

etTall = randint(1, 100)
gjetning = 0
antallForsoek = 0
brukerInput = ""
print("Python tenker på et tall mellom 1 til 100. Prøv å finne ut hvilket tall den tenker på.")
while gjetning != etTall and brukerInput != "quit":
    antallForsoek = antallForsoek + 1
    print("Forsøk", antallForsoek)
    brukerInput = input("Hva gjetter du ('quit' for å gi opp)? ")
    if brukerInput != "quit":
        gjetning = int(brukerInput)
        if gjetning < etTall:
            print("Det var for lavt")
        elif gjetning > etTall:
            print("Det var for høyt")
if brukerInput != "quit":
    print("Gratulerer! Du gjettet tallet på", antallForsoek, "forsøk")
else:
    print("Du ga opp :(")
\end{usncodebox}
\end{solution}

\begin{exercise}
Som ovenfor, men la nå programmet gjette på tallet du tenker på.
Start med å oppgi med input() grensene, samt det spesifikke tallet du tenker på. Programmet kjenner til grensene, men ikke tallet. Før du leser videre: prøv å tenk ut hvordan du skal programmere dette. Hvordan tenker du selv når det er du som gjetter? Kan du overføre den metoden til programmet?

(Ikke les videre før du har fundert litt på hvordan dette bør løses.) Cluet ligger i at programmet oppdaterer grensene sine når det gjetter for høyt eller for lavt. Sett opp en while-løkke der følgende foregår: 

Programmet starter med å gjette midt mellom nedre og øvre grense
(du må sørge for at det er et heltall, runde opp eller ned).
Den sjekker så mot det korrekte svaret. Prosedyren er da at hvis den gjettingen er for lav, så endres nedre grense til det maskinen akkurat gjettet. (Tenk etter om det er logisk.) 
Er gjettingen for høy, er det øvre grense som endres til det maskinen akkurat gjettet.
På denne måten blir området stadig snevret inn.

Neste gjetting foregår da i starten av while-løkka, den ene grensa er ny. Når maskinen gjetter riktig tall, avsluttes while-løkka. Det skrives da ut hvor mange forsøk den brukte. 

Utvidelse a): La programmet heller gjette et tilfeldig tall mellom den til enhver tid øvre og nedre grense i stedet for å gå mot midten av intervallet. Programmet er da typisk mindre effektivt, men muligens mer robust mot.

Utvidelse b): Hva skjer hvis du angir grensene 1 og 10, og så velger tallet 15? (NB: Du kan avbryte en evig loop ved å trykke CTRL+c i IPython-konsollen.) Kan du sikre deg mot dette i koden? Prøv. 
\end{exercise}
\begin{solution}
\begin{usncodebox}
from random import randint

antallForsoek = 0
brukerInput = ""
nedreGrense = 0
oevreGrense = 100
print("Tenk på et tall fra 1 til 100 så skal Python prøve å gjette tallet.")
while brukerInput != "r" and brukerInput != "quit" and oevreGrense != nedreGrense:
    antallForsoek = antallForsoek + 1
    gjetning = (oevreGrense + nedreGrense) // 2
    print("Python gjetter", gjetning)
    brukerInput = input("Var det for høyt, lavt, riktig eller skal du avslutte (h, l, r, quit)? ")
    if brukerInput == "h":
        oevreGrense = gjetning - 1
    elif brukerInput == "l":
        nedreGrense = gjetning + 1
if brukerInput == "r":
    print("Python klarte det på", antallForsoek, "forsøk")
elif oevreGrense == nedreGrense:
    print("Tallet var", oevreGrense)
    print("Python klarte det på", antallForsoek + 1, "forsøk")
else:
    print("Python fikk ikke lov til å gjette flere ganger :(")
\end{usncodebox}
\end{solution}

\section{Funksjoner}
Noen ganger trenger du å utføre samme identiske bit med kode flere steder i programmet ditt. En løsning er da å skrive den samme biten kode flere ganger. Det er en dårlig løsning. Det kan ta mye plass og gjøre koden din uoversiktlig. Og dersom du skal gjøre endringer i den koden, må du gjøre de samme endringene flere plasser. 

Den gode løsningen er å legge denne delen av koden inn i en funksjon. Så kan du kalle denne funksjonen fra ulike steder i programmet din.

Eksempel:
\begin{usncodebox}
def rettlinje(x, a, b=0):
    print("x:",x,"  a:", a, "  b:",b)
    y = a*x + b
    return y
    
y1 = rettlinje(2,1)
print(y1)
print(rettlinje(2,1,10))   # med konstantledd
\end{usncodebox}

Lagre gjerne programmet som \usnfilename{tut\_funksjon1.py}.

NB: Når du har implementert og kjørt denne i Spyder og fått ut noen tall som resultat, kan du fra det interaktive vinduet fortsette å bruke rettlinje-funksjonen. Ved å kjøre koden har du importert den og IPython-konsollen kjenner innholdet. 
Prøv:

\begin{usncodebox}
rettlinje(2,1,9) 
\end{usncodebox}

\paragraph*{Forstå koden}
En funksjon starter med def (define/definition). Så kommer navnet. Så kommer en liste med argumenter i parentes. Og til slutt må det stå et kolon. Selve funksjonskoden er rykket inn (indentert).

Navnet følger samme regler som variabelnavn:
\begin{itemize}
\item Det må være ett ord.
\item Det kan inneholde store og små bokstaver og tall samt underscore \_.
\item Navnet kan ikke starte med et tall.
\item Navnet kan heller ikke være identisk med et av de reserverte ordene (for, if, list, etc.) 
\end{itemize}

Argumenter:
\begin{itemize}
\item Har funksjonen ingen argumenter må du likevel ha med parentesene. 
\item Argumenter kan ha en default-verdi. I vårt eksempel er b lik 0 dersom det tredje argumentet er utelatt fra funksjonskallet, som er tilfellet i \usninlinecode{y1 = rettlinje(2,1)}.
\item Argumenter med default-verdi må stå sist i argumentasjonsrekken. Følgende funksjonsdefinisjon er f.eks. ikke tillatt:  \usninlinecode{def rettlinje(x, a=1, b):}
\item Når vi kaller en funksjon kan vi utelate de argumentene som har en default verdi, mens de som ikke har en defaultverdi må angis. 
\item Vi kan også ta med argumentsnavnene i funksjonskallet, f.eks. \usninlinecode{rettlinje(x=2, a=1, b=10)} som da betyr det samme som \usninlinecode{rettlinje(2, 1, 10)}. Ofte gir det mer oversiktlig kode å gjøre det på denne måten. Men linjen kan også bli veldig lang dersom variabelnavnene er lange. 
\end{itemize}

Return: 
Funksjonen avslutter ved å returnere en verdi (\usninlinecode{return y}), eller ved å returnere ingen verdi (\usninlinecode{return}), eller ved å komme til slutten i den aktuelle indenteringen. Det er altså ikke alltid en funksjon returnerer en verdi, men ofte er det slik. 

Funksjonen må være definert før den blir brukt. Dvs. vi kunne ikke hatt \usninlinecode{y1 = rettlinje(2,1)} før vi faktisk definerte fuksjonen. Da ville vi fått \usnoutput{NameError: not defined}. Altså: definisjonen må stå tidlig nok i programmet. 

Hva Python-interpreteren gjør når den kjører koden ovenfor:
\begin{itemize}
\item Interpreteren starter (alltid) øverst i filen.
\item Det første den møter er en funksjonsdefinisjon. Den laster prosedyren (funksjonen) inn i hukommelsen (og sjekker at syntaks er ok), og merker seg funksjonsnavnet. 
\item Så kommer den til \usninlinecode{y1 = rettlinje(2,1)}.
\item Den husker da at \usninlinecode{rettlinje()} er en funksjon. Den tar med seg argumentene: her blir x=2 og a=1, og b som er uspesifisert får default verdi som er 0, så blir funksjonen utført (eksekvert).
\item Når den kommer til \usninlinecode{return y}, går den tilbake til \usninlinecode{y1 = rettlinje(2,1)} og lar \usnvarname{y1} få verdien som ble returnert.
\item Så printer den. 
\item Så er det et nytt kall til \usninlinecode{rettlinje()} (inne i print). Interpreteren tar igjen med seg argumentene, kjører rettlinje-koden, og ved \usninlinecode{return y} gir den resultatet som argument til \usninlinecode{print()} i hovedprogrammet.
\item Når der ikke er mer kode, avslutter interpreteren og gir kontrollen tilbake til det interaktive vinduet. 
\end{itemize}

\paragraph*{Litt mer om return}

Se på følgende funksjon: 

\begin{usncodebox}
def fun1(x):
   if x<0:
      return "mindre enn 0"
   elif x>5:
      return "større enn 5"
   elif x>3: 
      #print("...mellom 3 og 5. Tom return.")
      return

   print("...mellom 0 og 3. Ingen return.")

aneg = fun1(-1.2)
a8 = fun1(8)
a4 = fun1(4)
a2 = fun1(2)

print("SVAR:") 
print("aneg:", aneg)
print("a8:", a8)
print("a4:", a4)
print("a2:", a2)
\end{usncodebox}

Lagre gjerne funksjonen som \usnfilename{tut\_funksjon2.py}

Her er det fire måter funksjonen kan returnere (avsluttes) på. Ved x<0 eller x>5 returnerer den en tekststreng, likt det vi hadde i forrige eksempel. Ved x mellom 3 og 5 blir funksjonen avsluttet med return, men ingenting blir returnert. Det som da blir returnert er spesialverdien None (Ingenting). Ved x mellom 0 og 3 er der ingen return, men funksjonen ender av seg self siden indenteringen ender. Da blir også None returnert.

Så det er alltid en verdi som blir returnert fra en funksjon. Men det er ikke alltid vi bryr oss om den. Noen ganger har vi en funksjon som ikke skal returnere noe f.eks. print().

Jo større et program er, jo viktigere er det å skille ut oppgaver til funksjoner. Også om den aktuelle koden blir kjørt bare én gang. En forutsetning for å plassere en oppgave i en funksjon er at oppgaven avhenger av et begrenset antall variabler og gjør endringer i et begrenset antall variabler. Det er ofte lett å se hva som kan høre hjemme i en funksjon. 

\begin{exercise}
Lag Trumps tvitre-funksjon. Den tar ingen argumenter, og la det i funksjonen tilfeldig velges mellom fire mulige utsagn. I programmet skal tvitre-funksjonen kalles 7 ganger. Prøv også å kalle funksjonen før den er definert. Og prøv å kalle funksjonen med et argument, f.eks. et tall. (Du skal få feilmeldinger.) 
\end{exercise}

\begin{exercise}
Lag en funksjon som tar argumentene t, v0 og a (tid, startfart og akselerasjon). La både v0 og a ha default-verdi lik 0 mens t ikke har default-verdi. Funksjonen skal regne ut og returnere  s = v0*t + 0.5*a * t**2 Sett opp en for-loop slik at en tidsvariabel går fra 0, 0.5, 1, ..., 10 (sekunder). For hver t-verdi skal funksjonen kalles med v0=0 og g=9.81, og tid og strekning skal printes ut. (Hvor langt faller man på 10 sekunder?)
\end{exercise}

\section{Variabler innenfor og utenfor en funksjoner (scope)}

Der finnes regler for hvor i programmet ulike variabler er synlige. 

En variabel som er definert inne i en funksjon (en variabel som er lokal for funksjonen), er ikke synlig utenfor funksjonen. Variabelen blir borte når funksjonen er ferdig. 

En variabel som er definert utenfor en funksjon, kan ikke nødvendigvis brukes eller endres inne i funksjonen.

Samme variabelnavn kan brukes flere steder i koden din uten at det nødvendigvis er den samme variabelen.

La oss se på noen situasjoner. Lag et nytt program (\usnmenulabel{File}\usnsubmenusep\usnmenulabel{New file}) og skriv inn følgende:
\begin{usncodebox}
x1 = 10
x2 = 20
x3 = 30

def fun1(x3):
    global x2, x5   # Med global sier vi at variablene x2 og x5 er globale variabler,  
                    # dvs. at de skal eksistere når fun1() er ferdig
    x1 = 13   # Lokal variabel. Vi endrer ikke variabelen x1 definert utenfor funksjonen. 
    x2 = 23   # x2 er den samme som x2 utenfor. Vi har endret fra 20 til 23. 
    x4 = 43
    x5 = 53
    print("innenfor: x1 er", x1)  #  13 (lokal variabel)
    print("innenfor: x2 er", x2)  #  23 (global variabel)
    print("innenfor: x3 er", x3)  # 130 (argumentsvariabel. Argumentet x3 skygger den globale x3)
    print("innenfor: x4 er", x4)  #  43 (lokal variabel)
    print("innenfor: x5 er", x5)  #  53 (har blitt satt til å være en global variabel)

fun1(130)
print("utenfor: x1 er", x1)   # 10 (har ikke blitt endra)
print("utenfor: x2 er", x2)   # 23 (har blitt endra)
print("utenfor: x3 er", x3)   # 30 (har ikke blitt endra)
print("utenfor: x4 er", x4)   # Denne gir feilmelding 
print("utenfor: x5 er", x5)   # 53 (Ble skapt i funksjonen, men satt til å være global. 
                              # Vanligvis ikke noe vi ønsker å gjøre.) 

\end{usncodebox}

Lagre gjerne programmet som \usnfilename{tut\_variablescope1.py}

Kjør programmet.

Du får feilmelding på nest siste linje fordi x4 er ikke synlig utenfor funksjonen. 

Kommenter den ut, dvs. sett \# helt til venstre i linjen. Kjør programmet på ny.

Studer utskriften. Prøv å forstå hvorfor variablene har de verdiene de har innenfor og utenfor programmet. Diskuter med sidemannen. Gjør endringer og test litt, se om ting oppfører seg slik du forventer.

\section{Gode programmeringsvaner (optional)}

Bruk nok kommentarer i koden din. Linjer som starter med \# er kommentarlinjer. Python bryr seg ikke om disse. Likedan med tekst som står til høyre for \# på en linje som inneholder kode. Når du skriver programmer er det lurt å legge inn nok kommentarer. De skal hjelpe deg til å skjønne hva du har tenkt når du ser på koden din en uke eller måned senere og kanskje skal forbedre den.

Dersom andre skal lese koden din, er det enda viktigere at den er godt kommentert. Man føler ofte man har dårlig tid når man koder, og at man derfor ikke har tid til å kommentere koden. Og kanskje at det heller ikke er nødvendig. Men: Selv om du akkurat nå umiddelbart ser hva en gitt del av programmet gjør og hvordan, er sjelden det tilfelle det neste gang du ser på programmet. Da må du bruke en del tid på å forstå hva du har gjort. Noen konsise kommentarer hjelper. (Men ikke skriv for mye heller, da skjuler du koden.) 

Kommentarlinjer brukes også til å debugge kode, finne feil. Du lurer f.eks. på hva en kodelinje gjør, om den har effekt i det hele tatt. Da kan du kommentere den ut og se hvilken effekt det har. (Det finnes mer avanserte metoder for debugging, se senere.)

Og kommentarlinjer kan brukes til enkel ``kodehistorikk''. Noen ganger har du gjort endringer i koden, men vil ikke fjerne den gamle måten å gjøre det på. Kanskje fordi du muligens vil gå tilbake til denne etterhvert. Da kommenterer du typisk ut linjen(e) enn så lenge i stedet for å slette de.

Hvis du ønsker å kommentere ut mange linjer med kode, kan du gjøre det ved å sette 3 apostrofer før og etter den delen du vil kommentere ut. Dette fungerer, men har i Python egentlig en annen funksjon, nemlig å dokumentere hva et program eller en funksjon gjør. Så for små prosjekter, som vi vil gjøre her, er det ok, men for større prosjekter, som også gjerne skal deles med andre, er det ikke anbefalt.  (Det er f.eks. vanlig å ha en slik "kommentar"-del i begynnelsen av fila. Der fortelles kanskje hvem som har laget programmet, når, og hva det gjør. Spyder legger inn noen slike linjer når du oppretter en ny fil. Du kan selv legge til kommentarer der.) 

Gode variabelnavn og funksjonsnavn er også viktig for å lage forståelig kode.

Variabelnavn: 
Der finnes mange forskjellige anbefalinger, f.eks.
\begin{usncodebox}
fart_bil = 3
FART_BIL = 3
fartBil = 3 (mixedCase)
FartBil = 3 (CamelCase)
\end{usncodebox}

Det er fint å holde seg til én konvensjon. 

Funksjoner:
Anbefalt: små bokstaver, underscore for å separere ord, f.eks. \usninlinecode{finne_fart()}, finne\_{}posisjon\_{}ball(), tegne\_{}graf(). (Tidligere har mixedCase også vært anbefalt.) 

Full info: \url{https://www.python.org/dev/peps/pep-0008/} (Style Guide for Python Code) 

\section{Debugging (optional)}

En feil i et program kalles en bug, fra engelsk. Debugging, feilretting, utgjør til tider mye av tiden vi bruker til programmering. 

Et program man akkurat har programmert ferdig fungerer sjelden helt som det skal. Ofte er der veldig åpenbare feil som får programmet til å kresje med en feilmelding. Da er det gjerne nok å se på den delen av programmet som feilmelding peker på. 

Andre ganger er feilen mindre åpenbar, både å oppdage, finne årsak til, og fjerne. Kanskje gir den ikke gi en feilmelding, men resultatet er likevel feil. F.eks. blir feil del av koden kjørt fordi en variabel i løpet av kjøring har fått en annen verdi enn du forventet. Der kan være mange grunner til det, og du må sjekke koden nærmere. 

Ofte hjelper det å sette inn print-linjer her og der i koden så du kan følge med på hvordan variabler endrer seg. Så kan du fjerne eller kommentere ut linjene når problemet er løst.

Men der finnes mer avanserte, mer effektive metoder. Spyder har debugging-funksjonalitet.
Se i toppmenyen: Debug.

La oss først lage et enkelt program:

\begin{usncodebox}
sko = ['Adidas','Puma','Nike']
kopi = []

for i in range(len(sko)): 
    print(i, sko[i])
    kopi.append(sko[i])

print('slutt')
\end{usncodebox}

Kall det gjerne \usnfilename{tut\_debugtest1.py} (\usnmenulabel{File}\usnsubmenusep\usnmenulabel{Save as})

Start debugging ved Debug/Debug eller CTRL+F5 (virker kanskje ikke) eller klikk på symbolet.

I IPython-konsollen har nå prompten blitt endret fra den vanlige \usninlinecode{In []:} til \usninlinecode{ipdb>}. Vi er i debugging-modus.  Det vises nå 5 linjer av programmet. Den midterste av de 5 har en pil på seg. Det er den linja python ser på akkurat nå (og venter). Mer korrekt: det er den linja python-interpreteren nå står klar til å lese.

Trykk Debug/Step eller CTRL+F10 eller klikk på symbolet. Nå kjørte vi akkurat den linja. Det var en kommentarlinje, så ingenting skjedde, men interpreteren hoppet akkurat ned til neste ikke-tomme linje. Den peker nå på linja som definerer variabelen sko. (Se på Variable explorer. Der er ingen variabel sko ennå.) Trykk Debug/Step for å utføre linjen. (Nå skal sko vises i Variable explorer.) Og koden hoppet ned en linje.

Den aktuelle (neste) linjen er også opplyst i Editor-vinduet, så det er lett å følge med på hvor interpreteren er. 

Debug/Step en gang til definerer variabelen kopi, og nå pekes det på for-løkka.

Underveis i debuggingen kan du printe variabler. (Det er ikke er så nyttig siden du har de i Variable explorer.) Prøv likevel i IPython-konsollen:
\begin{usncodebox}
print(sko)
\end{usncodebox}

Du kan også endre verdier. Det kan være aktuelt mens du debugger. Prøv:
\begin{usncodebox}
kopi.append('sokk')
\end{usncodebox}

Endringen vises ikke i Variable explorer med en gang, men vil gjøre det neste gang du trykker Debug/Step. 

Fortsett å trykke Debug/Step (og følg med i Variable explorer). Vi ser hvordan variablene i og kopi endres. Når kommandoene i løkka har blitt utført tre ganger, er den ferdig (hvorfor?), og kommer til siste print-kommandoen. Vi kan utføre denne også (Debug/Step). Men ikke klikk Debug/Step en gang til. Da hopper Spyder til en annen fil. Det vil vi ikke. (Har du likevel trykt en gang for mye, og f.eks. filen \usnfilename{sitecustomize.py} kommer opp i editoren, klikk den da bare bort, dvs. klikk på det hvite krysset på rød bakgrunn på tab'en øverst.)

Velg i stedet Debug/Stop eller CTRL+SHIFT+F12 (eller klikk symbolet). Da går vi ut av debuggeren. Prompten blir igjen \usninlinecode{In []:}

Der er flere funksjonaliteter i debuggeren. Noe har med hvordan du skal utføre funksjoner, linje for linje eller hele funksjonen.

Utføre løkke/funksjon med ett tastetrykk: 
La oss prøve en gang til, men nå uten å gå gjennom loopen gang på gang:
Trykk først CTRL+. for å restarte IPython-konsollen (og fjerne variablene).
Trykk så Debug-symbolet (eller Debug/Debug).
Trykk Debug/Step tre ganger.
Da står interpreteren og venter på for-linja. 
Nå vil du ikke gå inn i for-løkka, men utføre den i ett steg.
Trykk Debug/Step Return (eller CTRL+SHIFT+F11 eller symbolet).
Da utføres loopen, kopi-variabelen blir fylt og interpreteren venter på siste linje.
(Klikk Debug/Stop.)


Breakpoints: 
Og du trenger ikke kjøre linje for linje.
Det kan ta litt tid hvis programmet ditt er stort. 
Du kan sette breakpoints i koden din.
I Editorien gå til linja der du deklarerer kopi-variabelen.
Velg så Debug og Set/Clear breakpoint (eller trykk F12).
(Det kan gjøres både i vanleg mode og i debugging-mode. Vi er i vanlig mode nå.) 
Der kommer en rød prikk på linja, du har satt et breakpoint i koden din.
Interpreteren vil stoppe og vente på beskjed før den utfører denne linja. 
Trykk F12 en gang til, og du fjerner breakpointet.
Men vi vil ha det der, så sett det på igjen.
Gå så til siste print-linja og trykk F12 igjen.
Du har nå to breakpoints i koden din.

(Dersom du fortsatt er i debug-modus, velg Debug/Stop.)
For at vi skal starte med blanke ark, kan det være greit å velge
Consoles / Restart kernel (eller CTRL+.).
Det tar et par sekunder å restarte IPython-konsollen.
I Variable explorer ser du nå at alle variablene er borte.

La oss nå prøve debugging via breakpoints.
Trykk Debug/Start.
Trykk så Debug/Continue (eller CTRL+F12, eller klikk symbolet). 
Da hopper du rett til første breakpoint. 
Alt som er før har blitt utført, du ser at sko-variabelen allerede er fylt.
Trykk Debug/Continue en gang til.
Da utfører interpreteren alt helt frem til neste breakpoint, som er på siste linjen.
Når du er ferdig, velger du Debug/Stop.
(Du kunne også valgt Debug/Stop tidligere. Det kan du gjøre når som helst.) 

Det er nyttig å bli komfortabel nok med debugging-funsjonaliteten til at du
tar den i bruk når du har en mystisk bug i programmet ditt.
Det vil skje. 

\begin{exercise}
Legg til noen linjer i programmet ovenfor. Prøv deg litt frem med linje-for-linje-debugging. Prøv å gå gjennom loopen, og prøv å utføre den i et tastetrykk (Debug / Step Return). Og prøv breakpoint-debugging: sett noen breakpoints og forsikre deg om at du forstår. Prøv også å restarte IPython-konsollen (så variablene forsvinner). 
\end{exercise}

For mer info: Se Help-vinduet, klikk tutorial. Der er et kapittel om Debugging.

\section {Eksempel: Funksjon: Skrått kast (optional)}

(Kan evt. hoppe over denne.)
Bevegelse i x- og y-retning samtidig

\begin{usncodebox}
import time

def posisjon(t, v0=0, a=0):    # funksjon som regner ut posision med tid (t), startfart (v0) og akselerasjonen (a) gitt
    s = v0*t + 0.5*a*t**2      # posisjonen etter tid t
    return s                   # sender tilbake resultatet
    

# 45-graders kast
vx0 = 10         # startfart i x-retning (i m/s)
vy0 = 10         # startfart i y-retning (i m/s)
ay = -9.81       # (tyngde)akselerasjon i y-retning (nedover)

tid = 0
tid_steg = 0.1   # 
sx = 0
sy = 0

# while-løkka
while sy >= 0:                    # Vi holder på til ballen har nådd bakken 
    sx = posisjon(tid, vx0)       # Ingen akselerasjon i x-retning) 
    sy = posisjon(tid, vy0, ay)   # I y-retning har vi tyngdeakselerasjonen nedover.)
    print("tid:", tid, "s   x-posisjon:", sx, "m   y-posisjon:", sy, "m")              # uformatert print
    #print("tid: %4.2f s   x-posisjon: %5.1f m   y-posisjon: %5.2f m" %(tid, sx, sy))  # formatert print

    tid = tid + tid_steg          # oppdatering av tidsvariabelen
    time.sleep(tid_steg)          # denne funksjon stopper Python i tid_steg (0.1) sekunder. 
\end{usncodebox}

Det første vi ser når vi kjører programmet er at tids- og posisjonsutskrift er vanskelig å lese. Det er hovedsaklig fordi Python skriver ut tallene med ulikt antall desimaler. Det kan vi fikse. Kommenter ut print-linja (sett \# foran), og legg til følgende print-linje på linja under:

\begin{usncodebox}
print("tid: %4.2f s   x-posisjon: %5.2f m   y-posisjon: %5.2f m" %(tid, sx, sy) )
\end{usncodebox}

Kjør så på ny. Vi har nå formatert teksten. Vi har bestemt at tid skal vises med 2 desimal og ta opp minst 4 plasser, kommaet inkludert. Likedan skal både sx og sy vises med 2 desimaler og ta opp minst 5 plasser. Det blir mer systematisk. Mer om det nedenfor. 

\section{Formattering av print}

Det vi har gjort så langt (unntatt i siste eksempel) er å bruke print() slik: print(var1,var2,var3,..) der var1,var2,var3,... kan være variabler eller verdier.

F.eks.
\begin{usncodebox}
var1 = 'Dette'
var3 = 3.14159265
print(var1, 'er pi:', var3)

# Et ekstra mellomrom (space) blir satt inn der kommaet er. 
print('1 / 3 = ', 1/3)
\end{usncodebox}

Med denne metoden har vi ingen kontroll til å styre f.eks. hvor mange desimaler vi vil vise. For å få det, må vi formatere teksten. Der er to måter, den gamle "printf-metoden", og en ny metode. Den gamle metoden er veldig utbredd (bl.a. også i C), og kommer til å være det i lang tid. Vi vil derfor bruke den. 

Gammel metode (printf):
Der du vil ha en variabel legger du inn en formateringskode som starter 
med % og ender med en bokstav som angir variabeltype (int, float, ..).
Når du er ferdig med teksten følger variablene i en tuple etter %, 
slik: %(var1,var2,var3).  (NB: Tuple defineres i neste kapittel.) 

Heltall (int), ender med d, kan også bruke i (d er å foretrekke):
\begin{usncodebox}
print("Tekst %i tekst" %(343))     # viser tallet som det er (uformatert)
print("Tekst %d tekst" %(343))     # viser tallet som det er (uformatert) 
print("Tekst %5d tekst" %(343))    # setter av 5 plasser
print("Tekst %2d tekst" %(343))    # setter av 2 plasser, men 3 blir brukt (uheldig)
print("Tekst %8.5d tekst" %(343))  # setter av 8 plasser, de 5 siste har ledende nuller 
                                   # før tallet (dersom der er plass) 
print("Tekst %.5d tekst" %(343))   # setter av 5 plasser, der er ledende nuller før tallet
print("Tekst %d tekst" %(343.66))  # dersom variabelen er float, blir desimalene kastet. 
                                   # (Blir ikke avrundet, det ville gitt 344.)  
print("Tekst %i tekst" %('343')    # TypeError
\end{usncodebox}

Desimaltall (float), ender med f:  %TOTALBREDDE.ANTALLDESIMALERf
Eks. %5.2f
  Total bredde er da 5 (inkludert eventuelt fortegn)
  Antall desimaler er 2

\begin{usncodebox}

print("Noe %6.2f noe" %(43.1415))    # viser 'Noe  43.14 noe'
print("Noe %6.2f noe" %(43.1))       # viser 'Noe  43.10 noe'
print("Noe %.2f noe"  %(43.1))       # viser 'Noe 43.10 noe' 
                                     # Totalbredde ikke angitt. Python tar det den trenger
print("Noe %3.2f noe" %(43.1))       # viser 'Noe 43.10 noe'      
                                     # Når totalbredde er for liten i forhold til 
                                     # antall desimaler, komma og eventuelt fortegn, 
                                     # bruker Python så mye plass den trenger
print("Noe %5.2f noe" %(43))         # viser 'Noe  43.00 noe'     
                                     # Heltall blir gjort om til desimaltall
print("Noe %f noe"    %(43.14))      # viser 'Noe 43.140000 noe'  
                                     # Hvis ANTALLDESIMALER ikke er angitt, 
                                     # brukes 6 desimaler (systemavhengig?) 
print("Noe %5.2f noe" %(0.00001443)) # viser 'Noe  0.00 noe'      
                                     # Denne formateringen er ofte upraktisk for 
                                     # veldig små (eller store) tall
\end{usncodebox}

For både desimaltall og heltall kan vi bruke scientific (e) notasjon: 
\%TOTALBREDDE.ANTALLDESIMALERe   f.eks. \%10.2e
 
Dette formatet kan være nyttig når vi har veldig store eller veldig små tall eller ikke vet hvor stort/lite tallet er. 

\begin{usncodebox}
print("Sci %10.2e sci" %(12345689.88))   # viser "Sci   1.23e+07 sci" 
print("Sci %.2e sci" %(12345689.88))     # viser "Sci 1.23e+07 sci"    
                                         # TOTALBREDDE ikke spesifisert, Python tar det den trenger
print("Sci %.3e sci" %(.00000323456))    # viser "Sci 3.235e-06 sci"   # (runder av siste desimal)
\end{usncodebox}

Scientific notasjon har alltid 1 siffer foran komma. Eksponenten angis med to siffer.
1.3e+05 betyr 1.3*10**5
2.4e-07 betyr 2.4*10**(-7)   (som er det samme som 2.4/10**7)

Vi kan også bruke e-notasjonen selv.
\begin{usncodebox}
x = 1.60e-19    # Elementærladningen (i Coulomb) 
x = 1.01e+05    # Standard lufttrykk (i Pa) ved havoverflaten 
x = 1.01e5      # enklere
x = 1.01E5      # kan også bruke stor E
x = 1.01*10**5  # uten e-notasjon
\end{usncodebox}

Tekststrenger: \%s

\begin{usncodebox}
print("Str %s str" %("alle"))     # viser "Str alle str"    
                                  # bredde ikke spesifisert, Python tar det den trenger
print("Str %2s str" %("alle"))    # viser "Str alle str"    
                                  # ikke nok plasser, Python tar det den trenger
print("Str %6s str" %("alle"))    # viser "Str   alle str"  # høyre-justert
print("Str %-6s str" %("alle"))   # viser "Str alle   str"  # venstre-justert
\end{usncodebox}

Ny metode:
Vi går ikke gjennom den her. For info om den nye formateringsmetoden: se s.17 i boka eller f.eks. https://pyformat.info/

\begin{exercise}
Lag et program som trekker 10 tilfeldige (desimal)tall mellom -2000 og 2000 og skriver ut tallene med tre desimaler i en fin vertikal liste.
\end{exercise}

\begin{exercise}
Som ovenfor, men bruk nå scientific notasjon med 2 desimaler (eks: 1.25e+05)
\end{exercise}

\begin{exercise}
Lag et program som skriver ut navn, alder og fødselsmåned i fine kolonner. La navn være venstrejustert, og la fødselsmåned være høyrejustert.
\end{exercise}
\begin{usncodebox}
navn = ['Newton', 'Descartes', 'Euler'], alder = [84, 53, 76], 
foedt = ['januar','mars','april']
\end{usncodebox}

\section{Datatype: Tuples}

Datatyper vi kjenner: int, float, str, bool, list 

Datatype: tuple
En tuple er nesten som en liste.
Eksempler: 
\begin{usncodebox}
a = (1,9,3,4,5,8)
b = ('left','right')
type(b)    # gir tuple
a[0]       # gir 1 
b[1]       # gir 'right'
a[1:4]     # gir en tuple (9,3,4)
a[2:]      # gir en tuple (3,4,5,8)
a[:3]      # gir en tuple (1,9,3)
\end{usncodebox}

NB: husk tellemåten. Som i en liste har første element indeks 0. 

Men tupler kan ikke endres:
\begin{usncodebox}
a[0] = 11  # gir feilmelding
\end{usncodebox}

Og du kan ikke legge til elementer. 

Tupler kan brukes som nøkler/keys i dictionaries (se nedenfor), det kan være praktisk. 

\begin{exercise}
Lag en tuple (3,6,77) og skriv ut første, andre og tredje element, dvs. 3, 6 og 77.
Prøv å endre første elementet. (Du får feilmelding.) 
\end{exercise}

\begin{exercise}
Lag en tuple ('00','11','22','33','44','55'). Lag fra denne en ny tuple som har med elementene '11','22','33'. 
\end{exercise}

\begin{exercise}
Lag de 100 tuplene som kan lages av to siffer som begge er mellom 0 og 9, dvs. (0,0), (0,1), ..., (0,9), (1,0), (1,1), ..., (1,9), ..., (9,0), (9,1), .., (9,9)
(Tips: Bruk to for-løkker, den ene inni den andre.)
Legg tuplene inn i en liste som du laget ved start.
\end{exercise}

\section{Filer}

Ofte vil programmet ditt trenge å lese informasjon fra filer, f.eks. lese inn en ansattliste. Og ofte vil programmet ditt ønske å skrive informasjon til fil. Det finnes flere typer filer. Den enkleste er en ren tekstfil, det er det vi skal se på her. 

Lese fra tekstfil:
\begin{usncodebox}
fil1 = open('traktor.txt','r')    # Kobler til filen, 'r' (read) sier at vi kun skal lese fra filen
lines1 = fil1.readlines()         # Alle linjene leses inn i variabelen lines1 som da blir en liste
fil1.close()                      # Dekobler filen. 
\end{usncodebox}

Så vil du typisk gå gjennom linjene du leste inn, og gjøre noe (analysere, printe)
\begin{usncodebox}
for line1 in lines1:
    print line1.rstrip()
\end{usncodebox}

(Mer om rstrip() senere. Det fjerner et linjeskift på slutten av setningen.)

Skrive til fil: 
Anta at du har en liste med tekstlinjer, lines2:

\begin{usncodebox}
lines2 = ['Dette er', 'et par', 'linjer', 'med tekst']
\end{usncodebox}

Du ønsker så å skrive dette til fil.

Åpne filen for skriving, dvs. bruk 'w' i stedet for 'r'. Dersom filen eksisterer fra før, vil det tidligere innholdet bli slettet.

\begin{usncodebox}
fil2 = open('tekstfil1.txt','w')    
\end{usncodebox}

Loope gjennom lines2 og skrive til filen:
\begin{usncodebox}
for line2 in lines2:
    fil2.write("%s\n" %(line2))
fil2.close()
\end{usncodebox}

Siste linje lukker filen, nå er den lagret. 

Hvis du vil skrive mer til en eksisterende fil uten at det som er der fra før forsvinner, bruker du 'a' (for append) i stedet for 'w' når du åpner filen.

\begin{usncodebox}
fil2 = open('tekstfil1.txt','a')
\end{usncodebox}

Hvis filen ikke eksisterer fra før, vil den bli opprettet. 
 
\begin{exercise}
Lag et program som leser inn et par opplysninger fra tastaturet (navn, yrke etc.), skriver opplysningene til fil, og til slutt leser 
opplysningene fra filen og skriver de til skjerm. (Bruk gjerne \usnfilename{oppg\_skrivetilfil.py} som filnavn.)
\end{exercise}

\begin{exercise}
Lag et program som skriver til fil 20 linjer som hver skal inneholde linjenummer til venstre, så 5 tilfeldig valgte tall mellom 0 og 200 oppgitt med 3 desimaler. Tall-kolonnene skal være fint justerte.
\end{exercise}

\section{Datatype dictionaries (optional)}

Datatyper vi kjenner: int, float, str, bool, list, tuple 

Datatype: Dictionary (oppslagsliste)

\begin{usncodebox}
jeg = {}  # tom dictionary
jeg = {'navn':'Neo', 'alder':27, 'egenskaper':['utvalgt','rask'], 33:'et tall', 33.33:'et til'} 
type(jeg) 
\end{usncodebox}

Dictionaries består av et sett med keys (nøkler).
\begin{usncodebox}
- jeg.keys()  # viser keys (nøklene): 'navn', 'alder', ..
\end{usncodebox}

Keys kan bl.a. være tekststreng, tall, tuple, boolsk variable, men ikke en liste eller en annen dictionary. Til hver key er der en verdi.  Det er nesten ingen begrensninger på hvilken type verdien kan være: streng, tall, liste, andre dictionaries, ...

\begin{usncodebox}
jeg['navn']         # str
jeg['alder']        # int
jeg['egenskaper']   # list
jeg['navn'] = 'Aragorn'        # kan endre verdien til en eksisterende key
jeg['yrke'] = 'vandringsmann'  # kan legge til key/verdi 
\end{usncodebox}

Mens innholdet i en liste har en bestemt rekkefølge, er ikke dette tilfellet for en dictionary, nøklene er ikke sortert på noen måte.

Hva skjer viss du prøver en nøkkel som ikke finnes?
\begin{usncodebox}
jeg['bil']
\end{usncodebox}

Da får du KeyError. Det betyr at nøkkelen ikke finnes.

Hvordan teste om en nøkkel eksisterer? Testen er: 'bil' in jeg
F.eks.
\begin{usncodebox}
if 'bil' in jeg:
   print('Jeg har bil: ',jeg['bil'])
\end{usncodebox}

Noen ganger ønsker du å hente ut verdien, gi et alternativ verdi om nøkkelen ikke finnes. Det kan gjøres med dict.get(, ), f.eks. jeg.get('bil','ingen bil') Denne funksjonen returnerer verdien til 'bil', hvis 'bil' finnes. Hvis ikke, returnerer den 'ingen bil'.

Hvordan gå gjennom alle nøklene i en dictionary?
\begin{usncodebox}
for key in jeg.keys():
   print("  %-15s  %s" %(key, jeg[key]) ) 
\end{usncodebox}

Hvordan fjerne en nøkkel/verdi-par. 
\begin{usncodebox}
jeg.pop('alder')
\end{usncodebox}

eller ved å bruke del: 
\begin{usncodebox}
del jeg['alder']
\end{usncodebox}

del er en generell funksjon som fungerer på mange dataobjekter. (Forsiktig.) 

Hvordan slå sammen to dictionaries?
La oss si at vi hadde:
\begin{usncodebox}
mer_om_meg = {'sko':'gul', 'bukse':'svart'}   # fylle en ny dictionary
\end{usncodebox}
og ville legge disse inn i jeg. Det gjøres slik:
\begin{usncodebox}
jeg.update(mer_om_meg)
\end{usncodebox}
Alternativt kunne vi gått gjennom alle key/verdi-par i mer\_{}om\_{}meg, og lagt de til en for en.

Dictionaries er veldig fleksible, kan brukes til mye. F.eks. har du kanskje en liste med 100 kunder. For hver kunde vil du ha visse opplysninger. Da kunne det vært praktisk å ha en liste der hvert av elementene i listen er en dictionary. (Det kunne også vært relevant å bruke klasser (senere), men det er litt mer komplisert.)

\begin{exercise}
Lag et program som leser inn informasjon om fire personer fra tastaturet. For hver person skal fornavn, etternavn, alder leses inn og legges i en dictionary. Hver persons dictionary legges så inn i en liste. Til slutt skal det loopes gjennom listen og informasjonen skrives ut. (Bruk gjerne \usnfilename{oppg\_dictionary1.py} som filnavn.)
\end{exercise} 

\begin{exercise}
Lag en dictionary dct1 som inneholder navn og alder (som ovenfor). Dictionary'en inneholder også en key 'annet' som har annen dictionary som verdi. Denne dictionary'en har innhold {'hobby':'lego', 'mobiler':4}
\end{exercise}

\section{try-except (optional)}

Noen ganger vil programmet ditt kresje. Dette skjer f.eks. dersom du gjør følgende:
\begin{usncodebox}
alder = input()
alder = int(alder)
\end{usncodebox}

(som også kan skrives slik: alder = int(input()) ) og så skriver brukeren inn noe som ikke er et heltall, f.eks. 7.5 eller 'Jonas'. Da får du: ValueError: ... og programmet kresjer (ender). 

Det er mulig å plukke opp en slik feil, og håndtere den. 
Prøv:
\begin{usncodebox}
alder = input("Alder: ")
try:
    alder = int(alder)
except:
    print("%s er ingen gyldig alder. Din alder blir satt til 10 år." %(alder))
    alder = 10 

print("Du er %i år. Om 10 år er du %i år." %(alder, alder + 10)) 
\end{usncodebox}
    
Det som skjer her, er at den indenderte blokken under try: blir forsøkt utført. Dersom alt går fint, hopper programmet over except: og den indenderte blokken under, og fortsetter videre. Men dersom noe går galt i try-blokken, vil programmet glemme alt som der ble gjort, og koden i except-blokken vil bli utført i stedet. Metoden over fikser feilen (forsåvidt), og gjør programmet i stand til å kjøre videre. 

Men du ønsker kanskje å gi brukeren en mulighet til å rette opp feilen. Da kan du f.eks. gjøre noe slikt:

\begin{usncodebox}
alder = input("Alder: ")
fortsett = True     # en boolsk variabel som blir satt til False når vi har en gyldig alder

while fortsett: 
    try:
        alder = int(alder)
        fortsett = False
    except:
        alder = input("%s er ingen gyldig alder. Prøv igjen. Alder: " %(alder))

print("Du er %i år. Om 10 år er du %i år." %(alder, alder + 10)) 
\end{usncodebox}

Nå vil alderen bli innlest igjen og igjen helt til et heltall blir oppgitt. 

\begin{exercise}
Lag et program som trekker ti desimaltall mellom -10 og 10. For hvert tall skal kvadratroten regnes ut.
For negative tall vil imidlertid sqrt gi feilmelding, så skriv da i stedet ut melding om at kvadratroten ikke lar seg regne ut for dette tallet. Bruk try/except-konstruksjon til å gjennomføre. (NB: her kunne vi enkelt testet om tallet var negativt i stedet for å sette opp en try/except-konstruksjon.)
\end{exercise}

\section{Noen små triks}

Noen muligheter som finnes i Python. Noe av det er ikke anbefalt, men greit å ha sett det. 

Det er mulig å ha flere kommandoer på en linje, separert med semikolon:
\begin{usncodebox}
a = 3; b = 4
\end{usncodebox}

Det er mulig å skrive løkke på en linje (dersom det ikke er så mye du skal gjøre i løkka):
\begin{usncodebox}
for i in range(5): print(i)
for i in range(5): i2 = i**2; print("%i**2 = %2i" %(i, i2))
\end{usncodebox}

Men det er ikke anbefalt. 

Likedan er det mulig å ha enkel if-setning på en linje
\begin{usncodebox}
if i == 1: print(i)
\end{usncodebox}

Det er mulig å skrive følgende
\begin{usncodebox}
a = b = c = 0
\end{usncodebox}
Da blir alle satt til 0

Det er mulig å skrive følgende
\begin{usncodebox}
a += b    # samme som a = a + b
a -= b    # samme som a = a - b
a *= b    # samme som a = a * b
a \= b    # samme som a = a / b
\end{usncodebox}

Ofte brukt 
\begin{usncodebox}
i += 1    # samme som i = i + 1
\end{usncodebox}

Python har en funksjon som heter help. Prøv \usninlinecode{help(print)}

Du får litt info om print-funksjonen. Beskrivelsen er ganske teknisk, men litt informativ.
Prøv \usninlinecode{help(range)}

Der er det mye mer info. Det er ikke alltid så lett å finne frem til det man leter etter. Ofte er et søk på nettet raskeste vei, men help() kan også være til god hjelp. 

\section{Mer om tekststrenger}

Til en del programmeringsoppgaver må du kunne behandle tekststrenger.

funksjoner: strip, split, index, upper, lower, startswith, endswith, replace

\begin{usncodebox}
a = 'Ja'
b = 'Nei'
c = a + b    # Kan kombinere tekststrenger med +
print(c)

a = " Dette er en streng.  "
\end{usncodebox}

Skriv så \usnvarname{a} og trykk \usnkeypress{tab}. Der er ganske mange funksjoner for tekststrenger.

Prøv følgende og se hva de gjør: 
a.strip()
Mellomrommene (spacene) ved start og slutt blir fjernet.
Men funksjonen endrer ikke a
print(a)
Så for å endre a må du gjøre 
a = a.strip() 
print(a)

La oss begynne den forrige strengen igjen: 
a = " Dette er en streng.  "

Du kan også "strippe" bare ene siden:
\begin{usncodebox}
a.rstrip()    # right-strip
a.lstrip()    # left-strip
\end{usncodebox}

Hva om du vil lage en liste med alle ordene i tekststrengen.
\begin{usncodebox}
a.split()       # gir listen ['Dette', 'er', 'en', 'streng.']
\end{usncodebox}

Default er å splitte på mellomrom, som er det du vanligvis vil være ute etter. Men du kan splitte på hva du vil:
\begin{usncodebox}
a.split("er")   # gir listen [' Dette ', ' en streng.  ']
\end{usncodebox}

Telle antall ganger 'r' opptrer
\begin{usncodebox}
a.count('r')
\end{usncodebox}

Telle antall ganger 'er' opptrer
\begin{usncodebox}
a.count('er')
\end{usncodebox}

Finne indeks til (første) 'r':
\begin{usncodebox}
a.index('r')
\end{usncodebox}

Kan også finne første fra høyre:
\begin{usncodebox}
a.rindex('r')

a.upper()  # endre til store bokstaver
a.lower()  # endre til små bokstaver

a.startswith("Dette")  # False
a.startswith(" Det")   # True
a.endswith("reng.  ")      # True

a.replace(' er ', ' blir ')
\end{usncodebox}


Hermetegn inne i en tekststreng?
\begin{usncodebox}
print("Han sa 'Pass opp!'")
print('Han sa "Pass opp!"')
\end{usncodebox}
