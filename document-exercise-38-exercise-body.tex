% ------------------------------------------------------------------------
% file `document-exercise-38-exercise-body.tex'
%
%     exercise of type `exercise' with id `38'
%
% generated by the `exercise' environment of the
%   `xsim' package v0.11 (2018/02/12)
% from source `document' on 2018/08/08 on line 1216
% ------------------------------------------------------------------------
Som ovenfor, men la nå programmet gjette på tallet du tenker på.
Start med å oppgi med input() grensene, samt det spesifikke tallet du tenker på.
Programmet kjenner til grensene, men ikke tallet.
Før du leser videre: prøv å tenk ut hvordan du skal programmere dette.
Hvordan tenker du selv når det er du som gjetter?
Kan du overføre den metoden til programmet?

(Ikke les videre før du har fundert litt på hvordan dette bør løses.)
Cluet ligger i at programmet oppdaterer grensene sine når det gjetter for høyt
eller for lavt.
Set opp en while-løkke der følgende foregår:
Programmet starter med å gjette midt mellom nedre og øvre grense
(du må sørge for at det er et heltall, runde opp eller ned).
Den sjekker så mot det korrekte svaret.
Prosedyren er da at hvis den gjettingen er for lav,
så endres nedre grense til det maskinen akkurat gjettet.
(Tenk etter om det er logisk.)
Er gjettingen for høy, er det øvre grense som endres til det maskinen akkurat gjettet.
På denne måten blir området stadig snevret inn.

Neste gjetting foregår da i starten av while-løkka, den ene grensa er ny.
Når maskinen gjetter riktig tall, avsluttes while-løkka.
Det skrives da ut hvor mange forsøk den brukte.

Utvidelse a): La programmet heller gjette et tilfeldig tall mellom den til enhver tid
øvre og nedre grense i stedet for å gå mot midten av intervallet.
Programmet er da typisk mindre effektivt, men muligens mer robust mot.

Utvidelse b): Hva skjer hvis du angir grensene 1 og 10, og så velger tallet 15?
(NB: Du kan avbryte en evig loop ved å trykke CTRL+c i IPython-konsollen.)
Kan du sikre deg mot dette i koden? Prøv.
